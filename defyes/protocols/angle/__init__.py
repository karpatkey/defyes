import itertools
import logging
from decimal import Decimal
from typing import Iterator

from defabipedia import Chain
from karpatkit.cache import cache_contract_method
from karpatkit.helpers import listify, suppress_value
from web3 import Web3
from web3.exceptions import ContractCustomError, ContractLogicError

from defyes.types import Token, TokenAmount

from .autogenerated import Oracle, Treasury, VaultManager

logger = logging.getLogger(__name__)


# Borrow Module
# https://docs.angle.money/angle-borrowing-module/borrowing-module
# https://github.com/AngleProtocol/borrow-contracts/tree/main
class Treasury(Treasury):
    # https://developers.angle.money/borrowing-module-contracts/smart-contract-docs/treasury
    # https://github.com/AngleProtocol/borrow-contracts/tree/main/contracts/treasury
    default_addresses: dict[str, str] = {
        "ethereum": "0x8667DBEBf68B0BFa6Db54f550f41Be16c4067d60",
        "polygon": "0x2F2e0ba9746aae15888cf234c4EB5B301710927e",
        "arbitrum": "0x0D710512E100C171139D2Cf5708f22C680eccF52",
        Chain.GNOSIS: "0x5adDc89785D75C86aB939E9e15bfBBb7Fc086A87",
    }

    @listify
    def get_all_vault_managers_addrs(self) -> list[str]:
        """
        Returns all vault manager addresses from treasury.
        """
        yield from self.vault_managers_addrs

    @property
    def vault_managers_addrs(self) -> Iterator[str]:
        with suppress_value(ContractLogicError, "execution reverted"):
            for nvault in itertools.count():
                yield self.vault_manager_list(nvault)
        logger.debug("End of vault manager list reachead")

    @property
    def vault_managers(self) -> Iterator[VaultManager]:
        for vault_addr in self.vault_managers_addrs:
            yield VaultManager(self.blockchain, self.block, vault_addr)


class Oracle(Oracle):
    def get_decimals(self) -> int:
        if "EUR" in self.description:
            return 18
        else:
            raise ValueError("Not decimal specified")

    def rate(self) -> Decimal:
        return self.read / Decimal(10 ** self.get_decimals())


class VaultManager(VaultManager):
    def vaults_owned_by(self, wallet: str) -> int:
        wallet = Web3.to_checksum_address(wallet)
        return self.balance_of(wallet)

    def get_oracle(self) -> Oracle:
        return Oracle(self.blockchain, self.block, address=self.oracle)

    def vault_ids_owned_by(self, wallet: str, vault_ids: list) -> bool:
        if self.vaults_owned_by(wallet) != len(vault_ids):
            return False
        for vault_id in vault_ids:
            if self.owner_of(vault_id) != wallet:
                return False
        return True

    @cache_contract_method(validator=vault_ids_owned_by)
    def get_vault_ids_from(self, wallet: str) -> list:
        wallet = Web3.to_checksum_address(wallet)

        def vault_ids():
            for vault_id in range(self.vault_id_count + 1):
                with suppress_value(ContractCustomError, "0x0c5473ba"):
                    if wallet == self.owner_of(vault_id):
                        yield vault_id

        return {"wallet": wallet, "vault_ids": list(vault_ids())}

    def get_vault_data(self, vaultid: int, decimals: bool = True) -> dict:
        contract_decimals = str(self.base_params).count("0")
        collateral_factor_with_decimals = self.collateral_factor / Decimal(10**contract_decimals)

        interest_decimals = str(self.base_interest).count("0")
        interest_rate_per_second = self.interest_rate / Decimal(10**interest_decimals)

        debt_amount = self.get_vault_debt(vaultid)
        debt = TokenAmount.from_teu(-debt_amount, Token.get_instance(self.stablecoin, self.blockchain))

        collateral_deposit, normalized_debt = self.vault_data(vaultid)
        collateral = TokenAmount.from_teu(collateral_deposit, Token.get_instance(self.collateral, self.blockchain))

        collateral_to_stablecoin = self.get_oracle().rate()
        collateral_in_stablecoin = collateral_deposit * collateral_to_stablecoin

        # health_factor = collateral_in_stablecoin * self.collateral_factor / debt_amount
        available_to_borrow = collateral_in_stablecoin * collateral_factor_with_decimals - debt_amount
        available = TokenAmount.from_teu(available_to_borrow, Token.get_instance(self.stablecoin, self.blockchain))

        data = {
            "liquidity": {
                "underlyings": [
                    debt.as_dict(decimals),
                    collateral.as_dict(decimals),
                ],
            },
            "financial_metrics": {
                # "health_factor": health_factor,
                # "loan_to_value": debt_amount / collateral_in_stablecoin,
                "collateral_ratio": collateral_in_stablecoin / debt_amount,
                "liquidation_ratio": 1 / collateral_factor_with_decimals,
                "anual_interest_rate": interest_rate_per_second * 365 * 24 * 3600,
                "liquidation_price_in_stablecoin_fiat": -1
                * debt.balance(decimals)
                / collateral_factor_with_decimals
                / collateral.balance(decimals),
                "available_to_borrow": available.as_dict(decimals),
            },
        }
        return data


def get_protocol_data(blockchain: str, wallet: str, block: int | str = "latest", decimals: bool = True) -> dict:
    """
    TODO: Add documentation
    """
    wallet = Web3.to_checksum_address(wallet)
    treasury = Treasury(blockchain, block)

    positions = {}

    for vault_manager in treasury.vault_managers:
        if vault_manager.vaults_owned_by(wallet) >= 1:
            vault_ids = vault_manager.get_vault_ids_from(wallet)["vault_ids"]
            for vault_id in vault_ids:
                vault_data = vault_manager.get_vault_data(vault_id, decimals=decimals)
                positions[str(vault_id)] = vault_data
    return {
        "protocol": "Angle",
        "blockchain": blockchain,
        "wallet": Web3.to_checksum_address(wallet),
        "block_id": block,
        "positions_key": "vault_id",
        "positions": positions,
        "version": 0,
    }
