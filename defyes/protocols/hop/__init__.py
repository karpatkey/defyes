import json
import logging
from decimal import Decimal
from pathlib import Path

import requests
from defabipedia import Chain
from defabipedia.tokens import ArbitrumTokenAddr, EthereumTokenAddr, PolygonTokenAddr
from karpatkit.constants import ABI_TOKEN_SIMPLIFIED, Address
from karpatkit.explorer import ChainExplorer
from karpatkit.node import get_node
from web3 import Web3
from web3.exceptions import ContractLogicError

from defyes.functions import ensure_a_block_number, get_contract
from defyes.types import Addr, Token, TokenAmount

from .autogenerated import LiquidityPool, LiquidityPoolToken, Rewarder

logger = logging.getLogger(__name__)

DB_VERSION = "v0.0.190"
DB_FILENAME = "db_addrs.json"


BONDER_CHAINS = {
    Chain.ETHEREUM: {"balance": 1500000, "token": EthereumTokenAddr.DAI, "hdai": None},
    Chain.GNOSIS: {
        "balance": 100000,
        "token": Address.ZERO,
        "hdai": "0xB1ea9FeD58a317F81eEEFC18715Dd323FDEf45c4",
    },
    Chain.POLYGON: {
        "balance": 500000,
        "token": PolygonTokenAddr.DAI,
        "hdai": "0xb8901acB165ed027E32754E0FFe830802919727f",
    },
    Chain.ARBITRUM: {
        "balance": 100000,
        "token": ArbitrumTokenAddr.DAI,
        "hdai": "0x46ae9BaB8CEA96610807a275EBD36f8e916b5C61",
    },
    Chain.OPTIMISM: {
        "balance": 100000,
        "token": "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",
        "hdai": "0x56900d66D74Cb14E3c86895789901C9135c95b16",
    },
}


def update_db(filename=DB_FILENAME):
    url = f"https://github.com/hop-protocol/hop/raw/{DB_VERSION}/packages/core/src/addresses/mainnet.ts"
    response = requests.get(url)
    if response.status_code == 200:
        processed_lines = []
        for line in response.text.split("\n"):
            p_line = line.split("//")[0].rstrip().replace("'", '"')
            if ":" in p_line:
                key, data = p_line.split(":")
                key = key.split(":")[0].split(" ")
                p_line = " ".join(key[:-1]) + f'"{key[-1]}":' + data
            processed_lines.append(p_line)
        add_version = f'{{\n  "version": "{DB_VERSION}",\n'
        json_object = json.loads(add_version + "\n".join(processed_lines[3::]))

        with open(Path(__file__).parent / filename, "w") as outfile:
            json.dump(json_object, outfile, indent=2, default=lambda o: str(o))
    else:
        logger.debug("Failed to retrieve db. Status code: %s", response.status_code)


def get_lptokens_from_db(db_file=DB_FILENAME):
    with open(Path(__file__).parent / db_file, "r") as infile:
        data = json.load(infile)
    lp_tokens = {}
    for token, info in data["bridges"].items():
        for blockchain, addrs in info.items():
            for key, addr in addrs.items():
                if "LpToken" in key and addr != Address.ZERO:
                    lp_tokens[blockchain] = lp_tokens.get(blockchain, [])
                    lp_tokens[blockchain].append({"token": token, "addr": addr})

    return lp_tokens


def get_lptoken_data_from_db(lptoken_address: str, blockchain: Chain):
    possible_lp_tokens = get_lptokens_from_db()
    for lptoken in possible_lp_tokens[blockchain]:
        if lptoken["addr"] == lptoken_address:
            return lptoken


def get_rewards_contracts_from_db(db_file=DB_FILENAME):
    with open(Path(__file__).parent / db_file, "r") as infile:
        data = json.load(infile)["rewardsContracts"]
    rewards = {}
    for token, info in data.items():
        for blockchain, addrs in info.items():
            rewards[blockchain] = rewards.get(blockchain, {})
            rewards[blockchain][token] = addrs
    return rewards


class LiquidityPool(LiquidityPool):
    def get_underlyings(self, wallet: str, balance: int) -> list[TokenAmount]:
        underlying_balances = self.calculate_remove_liquidity(wallet, balance)
        underlying_amounts = []
        for n, underlying in enumerate(underlying_balances):
            t = Token.get_instance(self.get_token(n), self.blockchain, self.block)
            underlying_amounts.append(TokenAmount.from_teu(underlying, t))
        return underlying_amounts


class Rewarder(Rewarder):
    def get_reward(self, wallet: str) -> TokenAmount:
        balance = self.earned(wallet)
        t = Token.get_instance(self.rewards_token, self.blockchain, self.block)
        return TokenAmount.from_teu(balance, t)


class Bonder:
    def __init__(self, blockchain: str, block: int) -> None:
        self.block = block
        self.blockchain = blockchain
        self.address = "0x9298dfD8A0384da62643c2E98f437E820029E75E"
        self.node = get_node(blockchain, block)

    @property
    def native_balance(self) -> int:
        return self.node.eth.get_balance(self.address, self.block)

    def balance_of(self, token_address: str) -> int:
        balance = 0
        token_address = Web3.to_checksum_address(token_address)
        if token_address == Address.ZERO:
            balance = self.node.eth.get_balance(self.address, self.block)
        else:
            token_contract = self.node.eth.contract(address=token_address, abi=json.loads(ABI_TOKEN_SIMPLIFIED))
            try:
                balance = token_contract.functions.balanceOf(self.address).call(block_identifier=self.block)
            except ContractLogicError:
                pass
        return balance

    @property
    def decimals(self) -> int:
        return 18


def get_bonder_rewards(block: int, blockchain: Chain) -> dict:
    OP_opt = "0x4200000000000000000000000000000000000042"
    HOP_eth = "0xc5102fE9359FD9a28f877a67E36B0F050d81a3CC"

    date = ChainExplorer(blockchain).time_from_block(block)
    amounts = []
    for chain, chain_data in BONDER_CHAINS.items():
        chain_block = ChainExplorer(chain).block_from_time(date)
        bonder = Bonder(chain, chain_block)

        if chain == Chain.ETHEREUM:  # GET HOP
            hop_balance = bonder.balance_of(HOP_eth)
            token = Token.get_instance(HOP_eth, chain, chain_block)
            amounts.append(TokenAmount.from_teu(hop_balance, token))
        elif chain == Chain.OPTIMISM:  # GET OP
            op_balance = bonder.balance_of(OP_opt)
            token = Token.get_instance(OP_opt, chain, chain_block)
            amounts.append(TokenAmount.from_teu(op_balance, token))
        # CANONICAL CURRENCY
        canon_balance = bonder.balance_of(chain_data["token"])
        token = Token.get_instance(chain_data["token"], chain, chain_block)
        amounts.append(TokenAmount.from_teu(canon_balance, token))

        # hDAI
        if chain != Chain.ETHEREUM:
            hdais_rewards = bonder.balance_of(chain_data["hdai"])
            if hdais_rewards is not None:
                token = Token.get_instance(chain_data["hdai"], chain, chain_block)
                amounts.append(TokenAmount.from_teu(hdais_rewards, token))

    return amounts


def get_bonder_balances(block: int, blockchain: Chain) -> dict:
    date = ChainExplorer(blockchain).time_from_block(block)

    amounts = []
    for chain, chain_data in BONDER_CHAINS.items():
        chain_block = ChainExplorer(chain).block_from_time(date)
        # STAKED DAI
        balance = int(chain_data["balance"] * Decimal(10**18))
        token = Token.get_instance(chain_data["token"], chain, chain_block)

        # NATIVE CURRENCY
        bonder = Bonder(chain, chain_block)
        native_balance = bonder.native_balance

        if token.contract.address == Address.ZERO:
            balance += native_balance
            amounts.append(TokenAmount.from_teu(balance, token))
        else:
            amounts.append(TokenAmount.from_teu(balance, token))
            token = Token.get_instance(Address.ZERO, chain, chain_block)
            amounts.append(TokenAmount.from_teu(native_balance, token))

    return amounts


def get_protocol_data_for(
    blockchain: str,
    wallet: str,
    lptoken_address: str,
    block: int | str = "latest",
    decimals: bool = True,
) -> dict:
    wallet = Addr(Web3.to_checksum_address(wallet))
    lptoken_address = Web3.to_checksum_address(lptoken_address)
    block_id = ensure_a_block_number(block, blockchain)
    data = {"holdings": [], "underlyings": [], "unclaimed_rewards": [], "financial_metrics": {}}

    if lptoken_address == "0x9298dfD8A0384da62643c2E98f437E820029E75E":
        data["underlyings"] = get_bonder_balances(block_id, blockchain)
        data["unclaimed_rewards"] = get_bonder_rewards(block_id, blockchain)
    else:
        lptoken_data = get_lptoken_data_from_db(lptoken_address, blockchain)
        if lptoken_data is None:
            raise ValueError(f"Wrong lptoken provided ({lptoken_address}) for {blockchain}")

        lpt = LiquidityPoolToken(blockchain, block_id, lptoken_address)
        lp = LiquidityPool(blockchain, block_id, lpt.swap)

        # FIXME: review how to expose this information
        # balance = lpt.balance_of(wallet)
        # if balance:
        #    token = Token.get_instance(lptoken_address, blockchain, block_id)
        #    liquidity_holdings = [TokenAmount.from_teu(balance, token)]
        #    liquidity_underlyings = [lp.get_underlyings(wallet, balance)]

        reward_contracts = get_rewards_contracts_from_db()[blockchain][lptoken_data["token"]]
        staked_balance = 0
        reward_amounts = []
        for rewader in reward_contracts:
            r = Rewarder(blockchain, block_id, rewader)
            staked_balance += r.balance_of(wallet)
            unclaimed_reward = r.get_reward(wallet)
            if unclaimed_reward.amount > 0:
                reward_amounts.append(r.get_reward(wallet))
        data["unclaimed_rewards"] = reward_amounts

        if staked_balance > 0:
            token = Token.get_instance(lptoken_address, blockchain, block_id)
            data["holdings"] = [TokenAmount.from_teu(staked_balance, token)]
            data["underlyings"] = lp.get_underlyings(wallet, staked_balance)

    return data


# TODO: analize it
def get_balance(blockchain: str, address: str, block="latest") -> float:
    """Get balance of hop_brigde in a specific chain.

    N.B. CURRENTLY DEACTIVATED FOR FLUCTATIONS IN PRICE.

    Args:
        provider (str): URI of the provider.
        address (str): contract address.
        eth (bool, optional): If we need to follow eth logic or not. Defaults to False.

    Returns:
        float: balance of the hop_bridge for a specific chain.
    """
    BONDER_address = "0x9298dfD8A0384da62643c2E98f437E820029E75E"
    # Connect to the provider and create the contract
    contract = get_contract(address, blockchain=blockchain)  # provide hop_dai_bridge_abi.json

    # Get the credit and raw debit
    credit = contract.functions.getCredit(BONDER_address).call(block_identifier=block)
    raw_debit = contract.functions.getRawDebit(BONDER_address).call(block_identifier=block)

    # If ETH, we need to get the virtual debit else we get the pending transfers
    if blockchain == Chain.ETHEREUM:
        # Get the virtual debit (just for ETH)
        virtual_debit = contract.functions.getDebitAndAdditionalDebit(BONDER_address).call(block_identifier=block)
        balance = ((credit - raw_debit) + (virtual_debit - raw_debit)) / 1e18
    else:
        # Go through all the chains and get the pending transfers to L1 and L2
        pending_transfers = []
        for x in [
            1,
            10,
            100,
            42161,
            137,
        ]:  # 1: ETH, 10: OPT, 100: xDAI, 42161: ARB, 137: POL
            try:
                pending_transfers.append(contract.functions.pendingAmountForChainId(x).call(block_identifier=block))
            except Exception:
                print("Was not possible to retrieve:", x)
        balance = ((credit - raw_debit) + sum(pending_transfers)) / 1e18

    return Decimal(balance)
