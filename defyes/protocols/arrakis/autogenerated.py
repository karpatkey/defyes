"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import ArrakisV2, ArrakisHelperV2

# Optionally
class ArrakisV2(ArrakisV2):
    ...
"""

from karpatkit.node import get_node
from web3 import Web3

from defyes.generator import load_abi


class ArrakisV2:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "arrakis_v2.json"))

    def allowance(self, owner: str, spender: str) -> int:
        return self.contract.functions.allowance(owner, spender).call(block_identifier=self.block)

    def balance_of(self, account: str) -> int:
        return self.contract.functions.balanceOf(account).call(block_identifier=self.block)

    @property
    def decimals(self) -> int:
        return self.contract.functions.decimals().call(block_identifier=self.block)

    @property
    def factory(self) -> str:
        return self.contract.functions.factory().call(block_identifier=self.block)

    @property
    def get_pools(self) -> list[str]:
        return self.contract.functions.getPools().call(block_identifier=self.block)

    @property
    def get_ranges(self) -> list[tuple]:
        return self.contract.functions.getRanges().call(block_identifier=self.block)

    @property
    def get_routers(self) -> list[str]:
        return self.contract.functions.getRouters().call(block_identifier=self.block)

    @property
    def init0(self) -> int:
        return self.contract.functions.init0().call(block_identifier=self.block)

    @property
    def init1(self) -> int:
        return self.contract.functions.init1().call(block_identifier=self.block)

    @property
    def manager(self) -> str:
        return self.contract.functions.manager().call(block_identifier=self.block)

    @property
    def manager_balance0(self) -> int:
        return self.contract.functions.managerBalance0().call(block_identifier=self.block)

    @property
    def manager_balance1(self) -> int:
        return self.contract.functions.managerBalance1().call(block_identifier=self.block)

    @property
    def manager_fee_bps(self) -> int:
        return self.contract.functions.managerFeeBPS().call(block_identifier=self.block)

    @property
    def name(self) -> str:
        return self.contract.functions.name().call(block_identifier=self.block)

    @property
    def owner(self) -> str:
        return self.contract.functions.owner().call(block_identifier=self.block)

    @property
    def restricted_mint(self) -> str:
        return self.contract.functions.restrictedMint().call(block_identifier=self.block)

    @property
    def symbol(self) -> str:
        return self.contract.functions.symbol().call(block_identifier=self.block)

    @property
    def token0(self) -> str:
        return self.contract.functions.token0().call(block_identifier=self.block)

    @property
    def token1(self) -> str:
        return self.contract.functions.token1().call(block_identifier=self.block)

    @property
    def total_supply(self) -> int:
        return self.contract.functions.totalSupply().call(block_identifier=self.block)


class ArrakisHelperV2:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "arrakis_helper_v2.json"))

    @property
    def factory(self) -> str:
        return self.contract.functions.factory().call(block_identifier=self.block)

    def token0_and_token1_by_range(
        self, ranges_: list[tuple], token0_: str, token1_: str, vault_v2_: str
    ) -> tuple[list[tuple], list[tuple]]:
        """
        Output: amount0s, amount1s
        """
        return self.contract.functions.token0AndToken1ByRange(ranges_, token0_, token1_, vault_v2_).call(
            block_identifier=self.block
        )

    def token0_and_token1_plus_fees_by_range(
        self, ranges_: list[tuple], token0_: str, token1_: str, vault_v2_: str
    ) -> tuple[list[tuple], list[tuple], list[tuple], list[tuple]]:
        """
        Output: amount0s, amount1s, fee0s, fee1s
        """
        return self.contract.functions.token0AndToken1PlusFeesByRange(ranges_, token0_, token1_, vault_v2_).call(
            block_identifier=self.block
        )

    def total_liquidity(self, vault_: str) -> list[tuple]:
        """
        Output: liquidities
        """
        return self.contract.functions.totalLiquidity(vault_).call(block_identifier=self.block)

    def total_underlying(self, vault_: str) -> tuple[int, int]:
        """
        Output: amount0, amount1
        """
        return self.contract.functions.totalUnderlying(vault_).call(block_identifier=self.block)

    def total_underlying_at_price(self, vault_: str, sqrt_price_x96_: int) -> tuple[int, int]:
        """
        Output: amount0, amount1
        """
        return self.contract.functions.totalUnderlyingAtPrice(vault_, sqrt_price_x96_).call(block_identifier=self.block)

    def total_underlying_with_fees(self, vault_: str) -> tuple[int, int, int, int]:
        """
        Output: amount0, amount1, fee0, fee1
        """
        return self.contract.functions.totalUnderlyingWithFees(vault_).call(block_identifier=self.block)

    def total_underlying_with_fees_and_left_over(self, vault_: str) -> tuple:
        """
        Output: underlying
        """
        return self.contract.functions.totalUnderlyingWithFeesAndLeftOver(vault_).call(block_identifier=self.block)
