"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import Veolas

# Optionally
class Veolas(Veolas):
    ...
"""

from karpatkit.node import get_node
from web3 import Web3

from defyes.generator import load_abi


class Veolas:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "veOLAS.json"))

    def allowance(self, owner: str, spender: str) -> int:
        return self.contract.functions.allowance(owner, spender).call(block_identifier=self.block)

    def balance_of(self, account: str) -> int:
        """
        Output: balance
        """
        return self.contract.functions.balanceOf(account).call(block_identifier=self.block)

    def balance_of_at(self, account: str, block_number: int) -> int:
        """
        Output: balance
        """
        return self.contract.functions.balanceOfAt(account, block_number).call(block_identifier=self.block)

    @property
    def decimals(self) -> int:
        return self.contract.functions.decimals().call(block_identifier=self.block)

    def delegates(self, account: str) -> str:
        return self.contract.functions.delegates(account).call(block_identifier=self.block)

    def get_last_user_point(self, account: str) -> tuple:
        """
        Output: pv
        """
        return self.contract.functions.getLastUserPoint(account).call(block_identifier=self.block)

    def get_num_user_points(self, account: str) -> int:
        """
        Output: accountNumPoints
        """
        return self.contract.functions.getNumUserPoints(account).call(block_identifier=self.block)

    def get_past_total_supply(self, block_number: int) -> int:
        return self.contract.functions.getPastTotalSupply(block_number).call(block_identifier=self.block)

    def get_past_votes(self, account: str, block_number: int) -> int:
        """
        Output: balance
        """
        return self.contract.functions.getPastVotes(account, block_number).call(block_identifier=self.block)

    def get_user_point(self, account: str, idx: int) -> tuple:
        return self.contract.functions.getUserPoint(account, idx).call(block_identifier=self.block)

    def get_votes(self, account: str) -> int:
        return self.contract.functions.getVotes(account).call(block_identifier=self.block)

    def locked_end(self, account: str) -> int:
        """
        Output: unlockTime
        """
        return self.contract.functions.lockedEnd(account).call(block_identifier=self.block)

    def map_locked_balances(self, arg0: str) -> tuple[int, int]:
        """
        Output: amount, endTime
        """
        return self.contract.functions.mapLockedBalances(arg0).call(block_identifier=self.block)

    def map_slope_changes(self, arg0: int) -> int:
        return self.contract.functions.mapSlopeChanges(arg0).call(block_identifier=self.block)

    def map_supply_points(self, arg0: int) -> tuple[int, int, int, int, int]:
        """
        Output: bias, slope, ts, blockNumber, balance
        """
        return self.contract.functions.mapSupplyPoints(arg0).call(block_identifier=self.block)

    def map_user_points(self, arg0: str, arg1: int) -> tuple[int, int, int, int, int]:
        """
        Output: bias, slope, ts, blockNumber, balance
        """
        return self.contract.functions.mapUserPoints(arg0, arg1).call(block_identifier=self.block)

    @property
    def name(self) -> str:
        return self.contract.functions.name().call(block_identifier=self.block)

    @property
    def supply(self) -> int:
        return self.contract.functions.supply().call(block_identifier=self.block)

    def supports_interface(self, interface_id: bytes) -> bool:
        return self.contract.functions.supportsInterface(interface_id).call(block_identifier=self.block)

    @property
    def symbol(self) -> str:
        return self.contract.functions.symbol().call(block_identifier=self.block)

    @property
    def token(self) -> str:
        return self.contract.functions.token().call(block_identifier=self.block)

    @property
    def total_num_points(self) -> int:
        return self.contract.functions.totalNumPoints().call(block_identifier=self.block)

    @property
    def total_supply(self) -> int:
        return self.contract.functions.totalSupply().call(block_identifier=self.block)

    def total_supply_at(self, block_number: int) -> int:
        """
        Output: supplyAt
        """
        return self.contract.functions.totalSupplyAt(block_number).call(block_identifier=self.block)

    @property
    def total_supply_locked(self) -> int:
        return self.contract.functions.totalSupplyLocked().call(block_identifier=self.block)

    def total_supply_locked_at_t(self, ts: int) -> int:
        return self.contract.functions.totalSupplyLockedAtT(ts).call(block_identifier=self.block)
