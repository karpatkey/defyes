"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import LiquidityPool, PoolManager

# Optionally
class LiquidityPool(LiquidityPool):
    ...
"""

from karpatkit.node import get_node
from web3 import Web3

from defyes.generator import load_abi


class LiquidityPool:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "liquidity_pool.json"))

    @property
    def asset(self) -> str:
        return self.contract.functions.asset().call(block_identifier=self.block)

    def claimable_deposit_request(self, arg0: int, owner: str) -> int:
        """
        Output: claimableAssets
        """
        return self.contract.functions.claimableDepositRequest(arg0, owner).call(block_identifier=self.block)

    def claimable_redeem_request(self, arg0: int, owner: str) -> int:
        """
        Output: claimableShares
        """
        return self.contract.functions.claimableRedeemRequest(arg0, owner).call(block_identifier=self.block)

    def convert_to_assets(self, shares: int) -> int:
        """
        Output: assets
        """
        return self.contract.functions.convertToAssets(shares).call(block_identifier=self.block)

    def convert_to_shares(self, assets: int) -> int:
        """
        Output: shares
        """
        return self.contract.functions.convertToShares(assets).call(block_identifier=self.block)

    @property
    def decimals(self) -> int:
        return self.contract.functions.decimals().call(block_identifier=self.block)

    @property
    def escrow(self) -> str:
        return self.contract.functions.escrow().call(block_identifier=self.block)

    @property
    def exchange_rate_last_updated(self) -> int:
        return self.contract.functions.exchangeRateLastUpdated().call(block_identifier=self.block)

    @property
    def manager(self) -> str:
        return self.contract.functions.manager().call(block_identifier=self.block)

    def max_deposit(self, owner: str) -> int:
        """
        Output: maxAssets
        """
        return self.contract.functions.maxDeposit(owner).call(block_identifier=self.block)

    def max_mint(self, owner: str) -> int:
        """
        Output: maxShares
        """
        return self.contract.functions.maxMint(owner).call(block_identifier=self.block)

    def max_redeem(self, owner: str) -> int:
        """
        Output: maxShares
        """
        return self.contract.functions.maxRedeem(owner).call(block_identifier=self.block)

    def max_withdraw(self, owner: str) -> int:
        """
        Output: maxAssets
        """
        return self.contract.functions.maxWithdraw(owner).call(block_identifier=self.block)

    def pending_deposit_request(self, arg0: int, owner: str) -> int:
        """
        Output: pendingAssets
        """
        return self.contract.functions.pendingDepositRequest(arg0, owner).call(block_identifier=self.block)

    def pending_redeem_request(self, arg0: int, owner: str) -> int:
        """
        Output: pendingShares
        """
        return self.contract.functions.pendingRedeemRequest(arg0, owner).call(block_identifier=self.block)

    @property
    def pool_id(self) -> int:
        return self.contract.functions.poolId().call(block_identifier=self.block)

    def preview_deposit(self, arg0: int) -> int:
        return self.contract.functions.previewDeposit(arg0).call(block_identifier=self.block)

    def preview_mint(self, arg0: int) -> int:
        return self.contract.functions.previewMint(arg0).call(block_identifier=self.block)

    def preview_redeem(self, arg0: int) -> int:
        return self.contract.functions.previewRedeem(arg0).call(block_identifier=self.block)

    def preview_withdraw(self, arg0: int) -> int:
        return self.contract.functions.previewWithdraw(arg0).call(block_identifier=self.block)

    @property
    def share(self) -> str:
        return self.contract.functions.share().call(block_identifier=self.block)

    def supports_interface(self, interface_id: bytes) -> bool:
        return self.contract.functions.supportsInterface(interface_id).call(block_identifier=self.block)

    @property
    def total_assets(self) -> int:
        return self.contract.functions.totalAssets().call(block_identifier=self.block)

    @property
    def tranche_id(self) -> bytes:
        return self.contract.functions.trancheId().call(block_identifier=self.block)

    def wards(self, arg0: str) -> int:
        return self.contract.functions.wards(arg0).call(block_identifier=self.block)


class PoolManager:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "pool_manager.json"))

    def currency_address_to_id(self, arg0: str) -> int:
        """
        Output: currencyId
        """
        return self.contract.functions.currencyAddressToId(arg0).call(block_identifier=self.block)

    def currency_id_to_address(self, currency_id: int) -> str:
        return self.contract.functions.currencyIdToAddress(currency_id).call(block_identifier=self.block)

    @property
    def escrow(self) -> str:
        return self.contract.functions.escrow().call(block_identifier=self.block)

    @property
    def gateway(self) -> str:
        return self.contract.functions.gateway().call(block_identifier=self.block)

    def get_liquidity_pool(self, pool_id: int, tranche_id: bytes, currency: str) -> str:
        return self.contract.functions.getLiquidityPool(pool_id, tranche_id, currency).call(block_identifier=self.block)

    def get_liquidity_pool_1(self, pool_id: int, tranche_id: bytes, currency_id: int) -> str:
        return self.contract.functions.getLiquidityPool(pool_id, tranche_id, currency_id).call(
            block_identifier=self.block
        )

    def get_tranche_token(self, pool_id: int, tranche_id: bytes) -> str:
        return self.contract.functions.getTrancheToken(pool_id, tranche_id).call(block_identifier=self.block)

    def get_tranche_token_price(self, pool_id: int, tranche_id: bytes, currency: str) -> tuple[int, int]:
        """
        Output: price, computedAt
        """
        return self.contract.functions.getTrancheTokenPrice(pool_id, tranche_id, currency).call(
            block_identifier=self.block
        )

    @property
    def investment_manager(self) -> str:
        return self.contract.functions.investmentManager().call(block_identifier=self.block)

    def is_allowed_as_investment_currency(self, pool_id: int, currency: str) -> bool:
        return self.contract.functions.isAllowedAsInvestmentCurrency(pool_id, currency).call(
            block_identifier=self.block
        )

    @property
    def liquidity_pool_factory(self) -> str:
        return self.contract.functions.liquidityPoolFactory().call(block_identifier=self.block)

    def pools(self, pool_id: int) -> int:
        """
        Output: createdAt
        """
        return self.contract.functions.pools(pool_id).call(block_identifier=self.block)

    @property
    def restriction_manager_factory(self) -> str:
        return self.contract.functions.restrictionManagerFactory().call(block_identifier=self.block)

    @property
    def tranche_token_factory(self) -> str:
        return self.contract.functions.trancheTokenFactory().call(block_identifier=self.block)

    def undeployed_tranches(self, pool_id: int, arg1: bytes) -> tuple[int, str, str, int]:
        """
        Output: decimals, tokenName, tokenSymbol, restrictionSet
        """
        return self.contract.functions.undeployedTranches(pool_id, arg1).call(block_identifier=self.block)

    def wards(self, arg0: str) -> int:
        return self.contract.functions.wards(arg0).call(block_identifier=self.block)
