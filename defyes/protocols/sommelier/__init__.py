from collections import defaultdict
from decimal import Decimal

from web3 import Web3

from defyes.functions import ensure_a_block_number
from defyes.protocols import aura, balancer
from defyes.protocols.sommelier.autogenerated import CellarBalancerMultiAsset


def data_balancer_multi_asset(
    block, blockchain, underlying_pool_address, position_identifier, owned_shares_percentage, decimals=True
):
    """
    Get the underlying assets for a vault using balancer and aura.
    (CellarWithOracleWithBalancerFlashLoansWithMultiAssetDepositWithNativeSupport)

    First get the underlying assets from aura and balancer, then combine them and return the result.
    """
    aura_data = aura.underlying(
        position_identifier,
        underlying_pool_address,
        block,
        blockchain,
        decimals=decimals,
    )

    underlying_aura = []
    for key, value in aura_data["balances"].items():
        underlying_aura.append({"address": key, "balance": value})

    bal_result = balancer.get_protocol_data_for(
        blockchain,
        position_identifier,
        underlying_pool_address,
        block,
        decimals=decimals,
    )
    underlying_balancer = bal_result["positions"][underlying_pool_address]["liquidity"]["underlyings"]

    combined_list = underlying_aura + underlying_balancer

    balances = defaultdict(Decimal)
    for item in combined_list:
        balances[item["address"]] += item["balance"]

    result = [
        {"address": address, "balance": balance * Decimal(owned_shares_percentage)}
        for address, balance in balances.items()
    ]
    return result


POSITION_FUNCTIONS = {"0x6c1edce139291Af5b84fB1e496c9747F83E876c9": data_balancer_multi_asset}


def get_protocol_data_for(
    blockchain: str,
    wallet: str,
    position_identifier: str,
    block: int | str = "latest",
    decimals: bool = True,
) -> dict:
    """Get data from the Sommelier protocol.
    Different vaults have different functions to get the underlying assets.
    Currently only one vault is supported. To add more vaults, add more functions to the POSITION_FUNCTIONS dict.

    Args:
        position_identifier (str): The vault address to query.
    """
    wallet = Web3.to_checksum_address(wallet)
    position_identifier = Web3.to_checksum_address(position_identifier)
    block = ensure_a_block_number(block, blockchain)

    try:
        vault_function = POSITION_FUNCTIONS[position_identifier]
    except KeyError:
        raise ValueError(f"Position identifier {position_identifier} not supported.")

    # Get info on the sommelier vault
    cellar = CellarBalancerMultiAsset(blockchain, block, position_identifier)
    underlying_pool_address = cellar.asset
    holdings = cellar.balance_of(wallet)
    owned_shares_percentage = holdings / cellar.total_assets

    if decimals:
        holdings = holdings / 10**cellar.decimals

    # Get the underlying assets
    balance_data = vault_function(
        block, blockchain, underlying_pool_address, position_identifier, owned_shares_percentage
    )

    data_dict = {
        "blockchain": blockchain,
        "block": block,
        "protocol": "Sommelier",
        "positions_key": "vault_address",
        "version": 0,
        "wallet": wallet,
        "decimals": "",
        "positions": {
            position_identifier: {
                "underlyings": balance_data,
                "holdings": [{"address": position_identifier, "balance": holdings}],
            },
        },
    }

    return data_dict
