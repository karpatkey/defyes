from decimal import Decimal
from typing import List

from defabipedia import Chain
from defabipedia.tokens import EthereumTokenAddr
from web3 import Web3

from defyes.functions import ensure_a_block_number, to_token_amount
from defyes.types import Token, TokenAmount

from .autogenerated import Comet, CometRewards

# 30-1-2024
# only cUSDC and cWETH exists. There's no way to get a comet list from the blockchain.
COMETS = {
    "ethereum": [EthereumTokenAddr.cUSDCv3, EthereumTokenAddr.cWETHv3],
}


class CometRewards(CometRewards):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x1B0e765F6224C21223AeA2af16c1C46E38885a40",
    }


class Comet(Comet):
    def collaterals(self, wallet: str) -> list[TokenAmount]:
        collaterals = []
        n_assets = self.num_assets
        for n_asset in range(n_assets):
            info = self.get_asset_info(n_asset)
            addr = info[1]
            balance = self.user_collateral(wallet, addr)[0]
            if balance:
                token = Token.get_instance(addr, self.blockchain, self.block)
                collaterals.append(TokenAmount.from_teu(balance, token))
        return collaterals

    def borrowed(self, wallet: str) -> TokenAmount:
        balance = self.borrow_balance_of(wallet)
        token = Token.get_instance(self.base_token, self.blockchain, self.block)
        return TokenAmount.from_teu(balance, token)

    def aprs(self, wallet: str) -> dict:
        seconds_per_year = 60 * 60 * 24 * 365
        borrow_apr = self.get_borrow_rate(self.get_utilization) / (10**18) * seconds_per_year * 100
        supply_apr = self.get_supply_rate(self.get_utilization) / (10**18) * seconds_per_year * 100
        return {"borrow_apr": borrow_apr, "supply_apr": supply_apr}


def get_protocol_data_for(
    blockchain: str, wallet: str, lptoken_address: str, block: int | str = "latest", decimals: bool = True
) -> dict:
    block_id = ensure_a_block_number(block, blockchain)
    wallet = Web3.to_checksum_address(wallet)
    lptoken_address = Web3.to_checksum_address(lptoken_address)

    data = {"holdings": [], "underlyings": [], "unclaimed_rewards": [], "financial_metrics": {}}

    comet = Comet(blockchain, block_id, lptoken_address)
    balance = comet.balance_of(wallet)
    if balance:
        token = Token.get_instance(comet.base_token, blockchain, block_id)
        data["underlyings"] = [TokenAmount.from_teu(balance, token)]

    rewards = CometRewards(blockchain, block_id)
    comet_rewards = rewards.get_reward_owed(lptoken_address, wallet)
    if comet_rewards[1] > 0:
        token = Token.get_instance(comet_rewards[0], blockchain, block_id)
        data["unclaimed_rewards"] = [TokenAmount.from_teu(comet_rewards[1], token)]

    return data


def get_protocol_data(blockchain: str, wallet: str, block: int | str = "latest", decimals: bool = True) -> dict:
    """
    TODO: Add documentation
    """
    wallet = Web3.to_checksum_address(wallet)
    positions = {}

    for comet_address in COMETS[blockchain]:
        comet = Comet(blockchain, block, comet_address)
        balance = comet.balance_of(wallet)
        rewards = CometRewards(blockchain, block)
        comet_rewards = rewards.get_reward_owed(comet_address, wallet)

        if balance:
            positions[comet_address] = {
                "liquidity": {
                    "underlyings": [
                        {
                            "address": comet.base_token,
                            "balance": balance / Decimal(10**comet.decimals if decimals else 1),
                        },
                    ]
                }
            }

        if comet_rewards[1] > 0:
            positions[comet_address] = positions.get(comet_address, {})
            positions[comet_address]["unclaimed_rewards"] = [
                {
                    "address": comet_rewards[0],
                    "balance": to_token_amount(comet_rewards[0], comet_rewards[1], blockchain, decimals=decimals),
                }
            ]

        collaterals = comet.collaterals(wallet)
        if collaterals:
            positions[comet_address] = positions.get(comet_address, {})
            positions[comet_address]["collaterals"] = [c.as_dict(decimals) for c in collaterals]

        borrowed = comet.borrowed(wallet)
        if borrowed.amount:
            positions[comet_address] = positions.get(comet_address, {})
            positions[comet_address]["borrowred"] = borrowed.as_dict(decimals)

    return {
        "protocol": "Compoundv3",
        "blockchain": blockchain,
        "wallet": Web3.to_checksum_address(wallet),
        "block_id": block,
        "positions_key": "commet_address",
        "positions": positions,
        "version": 0,
    }


# TODO: deprecate
def underlying(wallet: str, comet_address: str, block: str | int, blockchain: str, decimals: bool = True) -> List[List]:
    """give the underlying token and amounts of this protocol

    Args:
        wallet (str): _description_
        comet_address (str): _description_
        block (str | int): _description_
        blockchain (str): _description_
        decimals (bool, optional): _description_. Defaults to True.
    """
    balances = []

    wallet = Web3.to_checksum_address(wallet)
    comet_address = Web3.to_checksum_address(comet_address)
    comet = Comet(blockchain, block, comet_address)
    balances.append([comet.base_token, comet.balance_of(wallet) / Decimal(10**comet.decimals if decimals else 1)])

    return balances


def get_all_rewards(
    wallet: str, comet_address: str, block: int | str, blockchain: str, decimals: bool = True
) -> List[List]:
    """_summary_

    Args:
        wallet (str): _description_
        block (int | str): _description_
        blockchain (str): _description_
        decimals (bool, optional): _description_. Defaults to True.

    Returns:
        List[List]: _description_
    """
    rewards = []
    wallet = Web3.to_checksum_address(wallet)
    comet_address = Web3.to_checksum_address(comet_address)

    comet = CometRewards(blockchain, block)
    comet_rewards = comet.get_reward_owed(comet_address, wallet)
    rewards.append(
        [comet_rewards[0], to_token_amount(comet_rewards[0], comet_rewards[1], blockchain, decimals=decimals)]
    )

    return rewards
