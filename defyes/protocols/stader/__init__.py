from typing import Union

from defabipedia import Chain
from karpatkit.constants import Address
from web3 import Web3

from defyes.functions import ensure_a_block_number
from defyes.protocols.stader.autogenerated import DepositPool, StakingPoolManagerEthx, StakingPoolManagerMaticx
from defyes.types import Token, TokenAmount

ETHx = "0xA35b1B31Ce002FBF2058D22F30f95D405200A15b"


class StakingPoolManager:
    def __init__(self, blockchain: str, block: int) -> None:
        self.blockchain = blockchain
        self.block = block
        if blockchain == Chain.ETHEREUM:
            self.pool = StakingPoolManagerEthx(blockchain, block, "0xcf5EA1b38380f6aF39068375516Daf40Ed70D299")
        elif blockchain == Chain.POLYGON:
            self.pool = StakingPoolManagerMaticx(blockchain, block, "0xfd225C9e6601C9d38d8F98d8731BF59eFcF8C0E3")
        else:
            raise ValueError(f"No implementation for {blockchain}")

    def convert_assets(self, amount: TokenAmount) -> int:
        if self.blockchain == Chain.ETHEREUM:
            balance = self.pool.convert_to_assets(int(amount.balance(False)))
            return TokenAmount.from_teu(balance, Token(Address.ZERO, self.blockchain, self.block))
        elif self.blockchain == Chain.POLYGON:
            balance = self.pool.convert_matic_x_to_matic(int(amount.balance(False)))[0]
            return TokenAmount.from_teu(
                balance, Token("0x0000000000000000000000000000000000001010", self.blockchain, self.block)
            )


def get_protocol_data_for(
    blockchain: str, wallet: str, lptoken_address: str, block: int | str = "latest", decimals: bool = True
) -> dict:
    block_id = ensure_a_block_number(block, blockchain)
    wallet = Web3.to_checksum_address(wallet)
    lptoken_address = Web3.to_checksum_address(lptoken_address)

    data = {"holdings": [], "underlyings": [], "unclaimed_rewards": [], "financial_metrics": {}}

    dp = DepositPool(blockchain, block_id, lptoken_address)
    token = Token.get_instance(lptoken_address, blockchain, block_id)
    balance = dp.balance_of(wallet)
    if balance:
        holding = TokenAmount.from_teu(balance, token)
        data["holdings"] = [holding]
        pool_manager = StakingPoolManager(blockchain, block_id)
        data["underlyings"] = [pool_manager.convert_assets(holding)]

    return data


def unwrap(amount: Union[int, float], block: Union[int, str], teu: bool = False) -> list:
    """Function to unwrap ETHx to ETH

    Args:
        amount (float): float amount of ETHx
        teu (False): if the provided amount is in teu or not. Default is False

    Returns:
        Decimal: Amount of ETH
    """
    poolmanager = StakingPoolManager(Chain.ETHEREUM, block)
    token = Token.get_instance(ETHx, Chain.ETHEREUM, block)

    # In case the amount is in teu just convert it to ETH else convert it to teu and then to ETH
    if teu:
        eth_unwrapped = poolmanager.convert_assets(TokenAmount(amount, token)).balance(True)
        eth_unwrapped = TokenAmount.from_teu(eth_unwrapped, token).balance(True)

    else:
        amount = TokenAmount(amount, token).balance()
        eth_unwrapped = poolmanager.convert_assets(TokenAmount(amount, token)).balance(True)
        eth_unwrapped = TokenAmount.from_teu(eth_unwrapped, token).balance(True)

    return [Address.ZERO, eth_unwrapped]
