from typing import Union

from defabipedia import Chain
from karpatkit.constants import Address
from web3 import Web3

from defyes.functions import ensure_a_block_number
from defyes.protocols.stader.autogenerated import DepositPool, StakingPoolManagerEthx, StakingPoolManagerMaticx
from defyes.types import Token, TokenAmount

ETHx = "0xA35b1B31Ce002FBF2058D22F30f95D405200A15b"
MaticX = "0xfa68FB4628DFF1028CFEc22b4162FCcd0d45efb6"


class StakingPoolManager:
    def __init__(self, blockchain: str, block: int) -> None:
        self.blockchain = blockchain
        self.block = block
        if blockchain == Chain.ETHEREUM:
            self.pool = StakingPoolManagerEthx(blockchain, block, "0xcf5EA1b38380f6aF39068375516Daf40Ed70D299")
        elif blockchain == Chain.POLYGON:
            self.pool = StakingPoolManagerMaticx(blockchain, block, "0xfd225C9e6601C9d38d8F98d8731BF59eFcF8C0E3")
        else:
            raise ValueError(f"No implementation for {blockchain}")

    def convert_assets(self, amount: TokenAmount) -> int:
        if self.blockchain == Chain.ETHEREUM:
            balance = self.pool.convert_to_assets(int(amount.balance(False)))
            return TokenAmount.from_teu(balance, Token(Address.ZERO, self.blockchain, self.block))
        elif self.blockchain == Chain.POLYGON:
            balance = self.pool.convert_matic_x_to_matic(int(amount.balance(False)))[0]
            return TokenAmount.from_teu(
                balance, Token("0x0000000000000000000000000000000000001010", self.blockchain, self.block)
            )


def get_protocol_data_for(
    blockchain: str, wallet: str, lptoken_address: str, block: int | str = "latest", decimals: bool = True
) -> dict:
    block_id = ensure_a_block_number(block, blockchain)
    wallet = Web3.to_checksum_address(wallet)
    lptoken_address = Web3.to_checksum_address(lptoken_address)

    data = {"holdings": [], "underlyings": [], "unclaimed_rewards": [], "financial_metrics": {}}

    dp = DepositPool(blockchain, block_id, lptoken_address)
    token = Token.get_instance(lptoken_address, blockchain, block_id)
    balance = dp.balance_of(wallet)
    if balance:
        holding = TokenAmount.from_teu(balance, token)
        data["holdings"] = [holding]
        pool_manager = StakingPoolManager(blockchain, block_id)
        data["underlyings"] = [pool_manager.convert_assets(holding)]

    return data


def unwrap(
    amount: Union[int, float], block: Union[int, str], teu: bool = False, blockchain: str = Chain.ETHEREUM
) -> list:
    """Function to unwrap ETHx/MaticX to ETH/Matic
    If the blockchain is Ethereum, the function will unwrap ETHx to ETH.
    If the blockchain is Polygon, the function will unwrap MaticX to Matic.

    Args:
        amount (float): float amount of ETHx/MaticX
        teu (False): if the provided amount is in teu or not. Default is False
        blockchain (str): the blockchain to use for conversion. Default is 'ethereum'

    Returns:
        Decimal: Amount of ETH/Matic
    """
    if blockchain.lower() == "ethereum":
        chain = Chain.ETHEREUM
        token = ETHx
    elif blockchain.lower() == "polygon":
        chain = Chain.POLYGON
        token = MaticX
    else:
        raise ValueError("Unsupported blockchain")

    poolmanager = StakingPoolManager(chain, block)
    token = Token.get_instance(token, chain, block)

    # In case the amount is in teu just convert it to ETH/Matic else convert it to teu and then to ETH/Matic
    if teu:
        converted_asset = poolmanager.convert_assets(TokenAmount(amount, token))
    else:
        amount = TokenAmount(amount, token).balance()
        converted_asset = poolmanager.convert_assets(TokenAmount(amount, token))

    unwrapped = TokenAmount.from_teu(converted_asset.balance(True), token).balance(True)

    address = str(converted_asset.token)

    return [address, unwrapped]
