"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import AlgebraFactory, AlgebraPool, AlgebraPositionNft

# Optionally
class AlgebraFactory(AlgebraFactory):
    ...
"""

from karpatkit.node import get_node
from web3 import Web3

from defyes.generator import load_abi


class AlgebraFactory:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "algebra_factory.json"))

    @property
    def base_fee_configuration(self) -> tuple[int, int, int, int, int, int, int, int, int]:
        """
        Output: alpha1, alpha2, beta1, beta2, gamma1, gamma2, volumeBeta,
        volumeGamma, baseFee
        """
        return self.contract.functions.baseFeeConfiguration().call(block_identifier=self.block)

    @property
    def default_community_fee(self) -> int:
        return self.contract.functions.defaultCommunityFee().call(block_identifier=self.block)

    @property
    def farming_address(self) -> str:
        return self.contract.functions.farmingAddress().call(block_identifier=self.block)

    @property
    def owner(self) -> str:
        return self.contract.functions.owner().call(block_identifier=self.block)

    def pool_by_pair(self, arg0: str, arg1: str) -> str:
        return self.contract.functions.poolByPair(arg0, arg1).call(block_identifier=self.block)

    @property
    def pool_deployer(self) -> str:
        return self.contract.functions.poolDeployer().call(block_identifier=self.block)

    @property
    def vault_address(self) -> str:
        return self.contract.functions.vaultAddress().call(block_identifier=self.block)


class AlgebraPool:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "algebra_pool.json"))

    @property
    def active_incentive(self) -> str:
        return self.contract.functions.activeIncentive().call(block_identifier=self.block)

    @property
    def data_storage_operator(self) -> str:
        return self.contract.functions.dataStorageOperator().call(block_identifier=self.block)

    @property
    def factory(self) -> str:
        return self.contract.functions.factory().call(block_identifier=self.block)

    def get_inner_cumulatives(self, bottom_tick: int, top_tick: int) -> tuple[int, int, int]:
        """
        Output: innerTickCumulative, innerSecondsSpentPerLiquidity,
        innerSecondsSpent
        """
        return self.contract.functions.getInnerCumulatives(bottom_tick, top_tick).call(block_identifier=self.block)

    def get_timepoints(self, seconds_agos: list[int]) -> tuple[list[int], list[int], list[int], list[int]]:
        """
        Output: tickCumulatives, secondsPerLiquidityCumulatives,
        volatilityCumulatives, volumePerAvgLiquiditys
        """
        return self.contract.functions.getTimepoints(seconds_agos).call(block_identifier=self.block)

    @property
    def global_state(self) -> tuple[int, int, int, int, int, int, bool]:
        """
        Output: price, tick, fee, timepointIndex, communityFeeToken0,
        communityFeeToken1, unlocked
        """
        return self.contract.functions.globalState().call(block_identifier=self.block)

    @property
    def liquidity(self) -> int:
        return self.contract.functions.liquidity().call(block_identifier=self.block)

    @property
    def liquidity_cooldown(self) -> int:
        return self.contract.functions.liquidityCooldown().call(block_identifier=self.block)

    @property
    def max_liquidity_per_tick(self) -> int:
        return self.contract.functions.maxLiquidityPerTick().call(block_identifier=self.block)

    def positions(self, arg0: bytes) -> tuple[int, int, int, int, int, int]:
        """
        Output: liquidity, lastLiquidityAddTimestamp, innerFeeGrowth0Token,
        innerFeeGrowth1Token, fees0, fees1
        """
        return self.contract.functions.positions(arg0).call(block_identifier=self.block)

    @property
    def tick_spacing(self) -> int:
        return self.contract.functions.tickSpacing().call(block_identifier=self.block)

    def tick_table(self, arg0: int) -> int:
        return self.contract.functions.tickTable(arg0).call(block_identifier=self.block)

    def ticks(self, arg0: int) -> tuple[int, int, int, int, int, int, int, bool]:
        """
        Output: liquidityTotal, liquidityDelta, outerFeeGrowth0Token,
        outerFeeGrowth1Token, outerTickCumulative, outerSecondsPerLiquidity,
        outerSecondsSpent, initialized
        """
        return self.contract.functions.ticks(arg0).call(block_identifier=self.block)

    def timepoints(self, index: int) -> tuple[bool, int, int, int, int, int, int]:
        """
        Output: initialized, blockTimestamp, tickCumulative,
        secondsPerLiquidityCumulative, volatilityCumulative, averageTick,
        volumePerLiquidityCumulative
        """
        return self.contract.functions.timepoints(index).call(block_identifier=self.block)

    @property
    def token0(self) -> str:
        return self.contract.functions.token0().call(block_identifier=self.block)

    @property
    def token1(self) -> str:
        return self.contract.functions.token1().call(block_identifier=self.block)

    @property
    def total_fee_growth0_token(self) -> int:
        return self.contract.functions.totalFeeGrowth0Token().call(block_identifier=self.block)

    @property
    def total_fee_growth1_token(self) -> int:
        return self.contract.functions.totalFeeGrowth1Token().call(block_identifier=self.block)


class AlgebraPositionNft:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "algebra_position_nft.json"))

    @property
    def domain_separator(self) -> bytes:
        return self.contract.functions.DOMAIN_SEPARATOR().call(block_identifier=self.block)

    @property
    def permit_typehash(self) -> bytes:
        return self.contract.functions.PERMIT_TYPEHASH().call(block_identifier=self.block)

    @property
    def w_native_token(self) -> str:
        return self.contract.functions.WNativeToken().call(block_identifier=self.block)

    def balance_of(self, owner: str) -> int:
        return self.contract.functions.balanceOf(owner).call(block_identifier=self.block)

    @property
    def base_uri(self) -> str:
        return self.contract.functions.baseURI().call(block_identifier=self.block)

    def burn(self, token_id: int):
        return self.contract.functions.burn(token_id).call(block_identifier=self.block)

    def collect(self, params: tuple) -> tuple[int, int]:
        """
        Output: amount0, amount1
        """
        return self.contract.functions.collect(params).call(block_identifier=self.block)

    def create_and_initialize_pool_if_necessary(self, token0: str, token1: str, sqrt_price_x96: int) -> str:
        """
        Output: pool
        """
        return self.contract.functions.createAndInitializePoolIfNecessary(token0, token1, sqrt_price_x96).call(
            block_identifier=self.block
        )

    def decrease_liquidity(self, params: tuple) -> tuple[int, int]:
        """
        Output: amount0, amount1
        """
        return self.contract.functions.decreaseLiquidity(params).call(block_identifier=self.block)

    @property
    def factory(self) -> str:
        return self.contract.functions.factory().call(block_identifier=self.block)

    def get_approved(self, token_id: int) -> str:
        return self.contract.functions.getApproved(token_id).call(block_identifier=self.block)

    def increase_liquidity(self, params: tuple) -> tuple[int, int, int]:
        """
        Output: liquidity, amount0, amount1
        """
        return self.contract.functions.increaseLiquidity(params).call(block_identifier=self.block)

    def is_approved_for_all(self, owner: str, operator: str) -> bool:
        return self.contract.functions.isApprovedForAll(owner, operator).call(block_identifier=self.block)

    def mint(self, params: tuple) -> tuple[int, int, int, int]:
        """
        Output: tokenId, liquidity, amount0, amount1
        """
        return self.contract.functions.mint(params).call(block_identifier=self.block)

    def multicall(self, data: list[bytes]) -> list[bytes]:
        """
        Output: results
        """
        return self.contract.functions.multicall(data).call(block_identifier=self.block)

    @property
    def name(self) -> str:
        return self.contract.functions.name().call(block_identifier=self.block)

    def owner_of(self, token_id: int) -> str:
        return self.contract.functions.ownerOf(token_id).call(block_identifier=self.block)

    def permit(self, spender: str, token_id: int, deadline: int, v: int, r: bytes, s: bytes):
        return self.contract.functions.permit(spender, token_id, deadline, v, r, s).call(block_identifier=self.block)

    @property
    def pool_deployer(self) -> str:
        return self.contract.functions.poolDeployer().call(block_identifier=self.block)

    def positions(self, token_id: int) -> tuple[int, str, str, str, int, int, int, int, int, int, int]:
        """
        Output: nonce, operator, token0, token1, tickLower, tickUpper,
        liquidity, feeGrowthInside0LastX128, feeGrowthInside1LastX128,
        tokensOwed0, tokensOwed1
        """
        return self.contract.functions.positions(token_id).call(block_identifier=self.block)

    @property
    def refund_native_token(self):
        return self.contract.functions.refundNativeToken().call(block_identifier=self.block)

    def self_permit(self, token: str, value: int, deadline: int, v: int, r: bytes, s: bytes):
        return self.contract.functions.selfPermit(token, value, deadline, v, r, s).call(block_identifier=self.block)

    def self_permit_allowed(self, token: str, nonce: int, expiry: int, v: int, r: bytes, s: bytes):
        return self.contract.functions.selfPermitAllowed(token, nonce, expiry, v, r, s).call(
            block_identifier=self.block
        )

    def self_permit_allowed_if_necessary(self, token: str, nonce: int, expiry: int, v: int, r: bytes, s: bytes):
        return self.contract.functions.selfPermitAllowedIfNecessary(token, nonce, expiry, v, r, s).call(
            block_identifier=self.block
        )

    def self_permit_if_necessary(self, token: str, value: int, deadline: int, v: int, r: bytes, s: bytes):
        return self.contract.functions.selfPermitIfNecessary(token, value, deadline, v, r, s).call(
            block_identifier=self.block
        )

    def supports_interface(self, interface_id: bytes) -> bool:
        return self.contract.functions.supportsInterface(interface_id).call(block_identifier=self.block)

    def sweep_token(self, token: str, amount_minimum: int, recipient: str):
        return self.contract.functions.sweepToken(token, amount_minimum, recipient).call(block_identifier=self.block)

    @property
    def symbol(self) -> str:
        return self.contract.functions.symbol().call(block_identifier=self.block)

    def token_by_index(self, index: int) -> int:
        return self.contract.functions.tokenByIndex(index).call(block_identifier=self.block)

    def token_of_owner_by_index(self, owner: str, index: int) -> int:
        return self.contract.functions.tokenOfOwnerByIndex(owner, index).call(block_identifier=self.block)

    def token_uri(self, token_id: int) -> str:
        return self.contract.functions.tokenURI(token_id).call(block_identifier=self.block)

    @property
    def total_supply(self) -> int:
        return self.contract.functions.totalSupply().call(block_identifier=self.block)

    def unwrap_w_native_token(self, amount_minimum: int, recipient: str):
        return self.contract.functions.unwrapWNativeToken(amount_minimum, recipient).call(block_identifier=self.block)
