import logging
from decimal import Decimal

from defabipedia import Chain
from web3 import Web3

from defyes.protocols.swaprv3.autogenerated import AlgebraFactory, AlgebraPool, AlgebraPositionNft

logger = logging.getLogger(__name__)


FACTORY: str = "0xA0864cCA6E114013AB0e27cbd5B6f4c8947da766"
POSITIONS_NFT: str = "0x91fd594c46d8b01e62dbdebed2401dde01817834"


AlgebraFactory.default_addresses = {Chain.GNOSIS: FACTORY}


class Pool(AlgebraPool):
    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        super().__init__(blockchain, block, address)
        sqrt_price_x96, self.current_tick = self.global_state()[0:2]
        self.sqrt_price = Decimal(sqrt_price_x96) / Decimal(2**96)
        self.price = self.sqrt_price**2

    def get_fee_growth_indexes(self, lower_tick: int, upper_tick: int) -> tuple:
        """Function to get the fee growth indexes for a given tick range. lower_tick and upper_tick.
        Here we can get the fee growth for global. ticks is the same"""
        fee_growth_0 = self.totalFeeGrowth0Token()
        fee_growth_1 = self.totalFeeGrowth1Token()
        fee_growth_outside_0_low, fee_growth_outside_1_low = self.ticks(lower_tick)[2:4]
        fee_growth_outside_0_up, fee_growth_outside_1_up = self.ticks(upper_tick)[2:4]

        return (
            fee_growth_0,
            fee_growth_1,
            fee_growth_outside_0_low,
            fee_growth_outside_1_low,
            fee_growth_outside_0_up,
            fee_growth_outside_1_up,
        )


class NFTPosition(AlgebraPositionNft):
    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        super().__init__(blockchain, block, address)
        self.BASETICK = 1.0001

    def set_nft_position(self, nftid: int):
        self.nftid = nftid
        nft_position_info = self.positions(self.nftid)
        (
            self.token0,
            self.token1,
            self.lower_tick,
            self.upper_tick,
            self.liquidity,
            self.fee_growth_inside_0,
            self.fee_growth_inside_1,
        ) = nft_position_info[2:9]

    def get_balance(
        self,
        current_tick: int,
        current_square_price: Decimal,
        fees_per_unit_0: int = 0,
        fees_per_unit_1: int = 0,
    ) -> list:
        balances = []
        if self.liquidity != 0:
            sa = Decimal(self.BASETICK) ** Decimal(int(self.lower_tick) / 2)
            sb = Decimal(self.BASETICK) ** Decimal(int(self.upper_tick) / 2)

            if self.upper_tick <= current_tick:
                amount0 = 0
                amount0fee = fees_per_unit_0 if fees_per_unit_0 > 0 else 0
                amount1 = self.liquidity * (sb - sa)
                amount1fee = fees_per_unit_1
            elif self.lower_tick < current_tick < self.upper_tick:
                amount0 = self.liquidity * (sb - current_square_price) / (current_square_price * sb)
                amount0fee = fees_per_unit_0
                amount1 = self.liquidity * (current_square_price - sa)
                amount1fee = fees_per_unit_1
            else:
                amount0 = self.liquidity * (sb - sa) / (sa * sb)
                amount0fee = fees_per_unit_0
                amount1 = 0
                amount1fee = fees_per_unit_1 if fees_per_unit_1 > 0 else 0

            amount0 = Decimal(amount0) + Decimal(amount0fee)
            amount1 = Decimal(amount1) + Decimal(amount1fee)

            if self.decimals:
                amount0 = amount0 / Decimal(10**self.decimals0)
                amount1 = amount1 / Decimal(10**self.decimals1)

            if amount0 > 0:
                balances.append([self.token0, amount0])

            if amount1 > 0:
                balances.append([self.token1, amount1])
        return balances


def get_id_nfts(wallet: str, nft_contract: NFTPosition) -> list:
    """Get all the NFT ids for a given wallet."""
    nft_ids = []
    number_nfts = nft_contract.balance_of(wallet)
    for nft_index in range(number_nfts):
        id = nft_contract.token_of_owner_by_index(wallet, nft_index)
        nft_ids.append(id)
    return nft_ids


def get_protocol_data_for(
    blockchain: str,
    wallet: str,
    position_identifier: str,
    block: int | str = "latest",
    decimals: bool = True,
) -> dict:
    """Get the data for a given wallet and position identifier."""
    wallet = Web3.to_checksum_address(wallet)
    position_identifier = Web3.to_checksum_address(position_identifier)

    # Initialize the NFT position contract and the Pool contract
    nft_position_contract = NFTPosition(blockchain, block, position_identifier)

    nft_ids = get_id_nfts(wallet, nft_position_contract)

    # create struct here

    for id in nft_ids:
        nft_position_contract.set_nft_position(id)

        pool_contract_address = AlgebraFactory(blockchain, block).pool_by_pair(
            nft_position_contract.token0, nft_position_contract.token1
        )

        pool = Pool(blockchain, block, pool_contract_address)

        balances = nft_position_contract.get_balance(pool.current_tick, pool.sqrt_price, id)
        print(balances)


if __name__ == "__main__":
    get_protocol_data_for(
        "gnosis", "0x458cd345b4c05e8df39d0a07220feb4ec19f5e6f", "0x91fD594c46D8B01E62dBDeBed2401dde01817834"
    )
