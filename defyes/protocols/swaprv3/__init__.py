import logging
from decimal import Decimal

from defabipedia import Chain
from web3 import Web3

from defyes.functions import ensure_a_block_number, get_decimals
from defyes.protocols.swaprv3.autogenerated import AlgebraFactory, AlgebraPool, AlgebraPositionNft

logger = logging.getLogger(__name__)


FACTORY: str = "0xA0864cCA6E114013AB0e27cbd5B6f4c8947da766"
POSITIONS_NFT: str = "0x91fd594c46d8b01e62dbdebed2401dde01817834"


AlgebraFactory.default_addresses = {Chain.GNOSIS: FACTORY}


class Pool(AlgebraPool):
    """A class to represent a SwaprV3 pool.

    Attributes:
        sqrt_price (Decimal): The square root of the price.
        price (Decimal): The price.
        current_tick (int): The current tick of the pool.
    """

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        super().__init__(blockchain, block, address)
        sqrt_price_x96, self.current_tick, self.fee = self.global_state[0:3]
        self.sqrt_price = Decimal(sqrt_price_x96) / Decimal(2**96)
        self.price = self.sqrt_price**2

    def get_fee_growth_indexes(self, lower_tick: int, upper_tick: int) -> tuple:
        """Gets the fee growth indexes for a given tick range."""
        fee_growth_0 = self.total_fee_growth0_token
        fee_growth_1 = self.total_fee_growth1_token
        fee_growth_outside_0_low, fee_growth_outside_1_low = self.ticks(lower_tick)[2:4]
        fee_growth_outside_0_up, fee_growth_outside_1_up = self.ticks(upper_tick)[2:4]

        return (
            fee_growth_0,
            fee_growth_1,
            fee_growth_outside_0_low,
            fee_growth_outside_1_low,
            fee_growth_outside_0_up,
            fee_growth_outside_1_up,
        )


class NFTPosition(AlgebraPositionNft):
    """A class to represent a SwaprV3 position.
    Takes the blockchain, block, and address of the NFT as arguments.

    Attributes:
        BASETICK (float): A constant value used in balance calculations.
    """

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        super().__init__(blockchain, block, address)
        self.BASETICK = 1.0001

    def set_nft_position(self, nftid: int):
        """Sets the NFT position based on the given NFT ID.

        Args:
            nftid (int): The ID of the NFT.
        """
        self.nftid = nftid
        nft_position_info = self.positions(self.nftid)
        (
            self.token0,
            self.token1,
            self.lower_tick,
            self.upper_tick,
            self.liquidity,
            self.fee_growth_inside_0,
            self.fee_growth_inside_1,
        ) = nft_position_info[2:9]
        self.decimals0 = get_decimals(self.token0, self.blockchain)
        self.decimals1 = get_decimals(self.token1, self.blockchain)

    def get_balance(
        self,
        current_tick: int,
        current_square_price: Decimal,
        decimals: bool = True,
        fees_per_unit_0: int = 0,
        fees_per_unit_1: int = 0,
    ) -> list:
        """Calculates and returns the balances of the NFT position.

        Args:
            current_tick (int): The current tick.
            current_square_price (Decimal): The current square price.

        Returns:
            list: The balance of the NFT position. -> [[token_address, balance], ...]
        """
        balances = []
        if self.liquidity != 0:
            sa = Decimal(self.BASETICK) ** Decimal(int(self.lower_tick) / 2)
            sb = Decimal(self.BASETICK) ** Decimal(int(self.upper_tick) / 2)

            if self.upper_tick <= current_tick:
                amount0 = 0
                amount0fee = fees_per_unit_0 if fees_per_unit_0 > 0 else 0
                amount1 = self.liquidity * (sb - sa)
                amount1fee = fees_per_unit_1
            elif self.lower_tick < current_tick < self.upper_tick:
                amount0 = self.liquidity * (sb - current_square_price) / (current_square_price * sb)
                amount0fee = fees_per_unit_0
                amount1 = self.liquidity * (current_square_price - sa)
                amount1fee = fees_per_unit_1
            else:
                amount0 = self.liquidity * (sb - sa) / (sa * sb)
                amount0fee = fees_per_unit_0
                amount1 = 0
                amount1fee = fees_per_unit_1 if fees_per_unit_1 > 0 else 0

            amount0 = Decimal(amount0) + Decimal(amount0fee)
            amount1 = Decimal(amount1) + Decimal(amount1fee)

            if decimals:
                amount0 = amount0 / Decimal(10**self.decimals0)
                amount1 = amount1 / Decimal(10**self.decimals1)

            if amount0 > 0:
                balances.append([self.token0, amount0])

            if amount1 > 0:
                balances.append([self.token1, amount1])
        return balances

    def get_fees(
        self,
        current_tick: int,
        fee_growth_0: int,
        fee_growth_1: int,
        fee_growth_outside_0_low: int,
        fee_growth_outside_1_low: int,
        fee_growth_outside_0_up: int,
        fee_growth_outside_1_up: int,
    ) -> list:
        # Calculate the fees per unit of liquidity for each token function. Just used inside here
        def calculate_fees_per_unit(fee_growth, fee_lower_token, fee_upper_token, fee_growth_inside):
            return Decimal(
                (fee_growth - fee_lower_token - fee_upper_token - fee_growth_inside) * self.liquidity
            ) / Decimal(2**128)

        if current_tick >= self.lower_tick:
            fee_lower_token0 = fee_growth_outside_0_low
            fee_lower_token1 = fee_growth_outside_1_low
        else:
            fee_lower_token0 = fee_growth_0 - fee_growth_outside_0_low
            fee_lower_token1 = fee_growth_1 - fee_growth_outside_1_low
        if current_tick >= self.upper_tick:
            fee_upper_token0 = fee_growth_0 - fee_growth_outside_0_up
            fee_upper_token1 = fee_growth_1 - fee_growth_outside_1_up
        else:
            fee_upper_token0 = fee_growth_outside_0_up
            fee_upper_token1 = fee_growth_outside_1_up

        fees_per_unit_0 = calculate_fees_per_unit(
            fee_growth_0, fee_lower_token0, fee_upper_token0, self.fee_growth_inside_0
        )
        fees_per_unit_1 = calculate_fees_per_unit(
            fee_growth_1, fee_lower_token1, fee_upper_token1, self.fee_growth_inside_1
        )

        return [fees_per_unit_0, fees_per_unit_1]


def get_fees(pool: Pool, nft_position: NFTPosition, decimals: bool = True) -> list:
    """Returns the unclaimed fees corresponding to a nft id.
    Given a pool and a nft position, it calculates the fees per unit of liquidity for each token.
    """
    unclaimed_fees = []

    growth_indexes = pool.get_fee_growth_indexes(nft_position.lower_tick, nft_position.upper_tick)
    fees_per_unit_0, fees_per_unit_1 = nft_position.get_fees(pool.current_tick, *growth_indexes)
    if decimals:
        fees_per_unit_0 = fees_per_unit_0 / Decimal(10**nft_position.decimals0)
        fees_per_unit_1 = fees_per_unit_1 / Decimal(10**nft_position.decimals1)

    unclaimed_fees.append({"address": nft_position.token0, "balance": fees_per_unit_0})
    unclaimed_fees.append({"address": nft_position.token1, "balance": fees_per_unit_1})

    return unclaimed_fees


def get_id_nfts(wallet: str, nft_contract: NFTPosition) -> list:
    """Get all the NFT ids for a given wallet."""
    nft_ids = []
    number_nfts = nft_contract.balance_of(wallet)
    for nft_index in range(number_nfts):
        id = nft_contract.token_of_owner_by_index(wallet, nft_index)
        nft_ids.append(id)
    return nft_ids


def get_protocol_data_for(
    blockchain: str | Chain,
    wallet: str,
    position_identifier: str,
    block: int | str = "latest",
    decimals: bool = True,
) -> dict:
    """Gets protocol data for a given blockchain, wallet, and position identifier.

    Args:
        blockchain (str | Chain): The blockchain name.
        wallet (str): The wallet address.
        position_identifier (str): The address of the ERC721 position. (NonFungiblePositionManager contract address)
        block (int | str, optional): The block number or "latest". Defaults to "latest".
        decimals (bool, optional): Whether to return the balance in decimals. Defaults to True.

    Returns:
        dict: A dictionary containing the protocol balances.
    """
    wallet = Web3.to_checksum_address(wallet)
    position_identifier = Web3.to_checksum_address(position_identifier)
    block = ensure_a_block_number(block, blockchain)

    # Initialize the NFT position contract to get the nft Ids
    nft_position_contract = NFTPosition(blockchain, block, position_identifier)

    nft_ids = get_id_nfts(wallet, nft_position_contract)

    # Initialize the dictionary to return
    data = {
        "blockchain": blockchain,
        "block": block,
        "protocol": "SwaprV3",
        "positions_key": "nft_id",
        "version": 3,
        "wallet": wallet,
        "decimals": 18,
    }

    positions = {}

    # For each nft id get the balances and add it to the positions dictionary
    for id in nft_ids:
        nft_position_contract.set_nft_position(id)

        pool_contract_address = AlgebraFactory(blockchain, block).pool_by_pair(
            nft_position_contract.token0, nft_position_contract.token1
        )

        pool = Pool(blockchain, block, pool_contract_address)

        balances = nft_position_contract.get_balance(pool.current_tick, pool.sqrt_price, decimals=decimals)

        unclaimed_fees = get_fees(pool, nft_position_contract, decimals=decimals)

        underlying = []

        # Add the data to the positions dictionary only if there are balances associated with the nft id
        if balances:
            for token in balances:
                underlying.append({"address": token[0], "balance": token[1]})
            positions[id] = {
                "underlyings": underlying,
                "holdings": {"address": position_identifier, "balance": 1},
                "rewards": unclaimed_fees,
            }

    data["positions"] = positions

    return data
