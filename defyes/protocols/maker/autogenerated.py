"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import ProxyRegistry, CdpManager, IlkRegistry, Vat, McdSpot, Pot, DsrManager, Sdai, Iou

# Optionally
class ProxyRegistry(ProxyRegistry):
    ...
"""

from karpatkit.node import get_node
from web3 import Web3

from defyes.generator import load_abi


class ProxyRegistry:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "proxy_registry.json"))

    def proxies(self, arg0: str) -> str:
        return self.contract.functions.proxies(arg0).call(block_identifier=self.block)


class CdpManager:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "cdp_manager.json"))

    def cdp_can(self, arg0: str, arg1: int, arg2: str) -> int:
        return self.contract.functions.cdpCan(arg0, arg1, arg2).call(block_identifier=self.block)

    @property
    def cdpi(self) -> int:
        return self.contract.functions.cdpi().call(block_identifier=self.block)

    def count(self, arg0: str) -> int:
        return self.contract.functions.count(arg0).call(block_identifier=self.block)

    def first(self, arg0: str) -> int:
        return self.contract.functions.first(arg0).call(block_identifier=self.block)

    def ilks(self, arg0: int) -> bytes:
        return self.contract.functions.ilks(arg0).call(block_identifier=self.block)

    def last(self, arg0: str) -> int:
        return self.contract.functions.last(arg0).call(block_identifier=self.block)

    def _list(self, arg0: int) -> tuple[int, int]:
        """
        Output: prev, next
        """
        return self.contract.functions.list(arg0).call(block_identifier=self.block)

    def owns(self, arg0: int) -> str:
        return self.contract.functions.owns(arg0).call(block_identifier=self.block)

    def urn_can(self, arg0: str, arg1: str) -> int:
        return self.contract.functions.urnCan(arg0, arg1).call(block_identifier=self.block)

    def urns(self, arg0: int) -> str:
        return self.contract.functions.urns(arg0).call(block_identifier=self.block)

    @property
    def vat(self) -> str:
        return self.contract.functions.vat().call(block_identifier=self.block)


class IlkRegistry:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "ilk_registry.json"))

    @property
    def cat(self) -> str:
        return self.contract.functions.cat().call(block_identifier=self.block)

    @property
    def count(self) -> int:
        return self.contract.functions.count().call(block_identifier=self.block)

    def dec(self, ilk: bytes) -> int:
        return self.contract.functions.dec(ilk).call(block_identifier=self.block)

    @property
    def dog(self) -> str:
        return self.contract.functions.dog().call(block_identifier=self.block)

    def gem(self, ilk: bytes) -> str:
        return self.contract.functions.gem(ilk).call(block_identifier=self.block)

    def get(self, pos: int) -> bytes:
        return self.contract.functions.get(pos).call(block_identifier=self.block)

    def ilk_data(self, arg0: bytes) -> tuple[int, str, str, int, int, str, str, str, str]:
        """
        Output: pos, join, gem, dec, class, pip, xlip, name, symbol
        """
        return self.contract.functions.ilkData(arg0).call(block_identifier=self.block)

    def info(self, ilk: bytes) -> tuple[str, str, int, int, str, str, str, str]:
        """
        Output: name, symbol, class, dec, gem, pip, join, xlip
        """
        return self.contract.functions.info(ilk).call(block_identifier=self.block)

    def join(self, ilk: bytes) -> str:
        return self.contract.functions.join(ilk).call(block_identifier=self.block)

    @property
    def _list(self) -> list[bytes]:
        return self.contract.functions.list().call(block_identifier=self.block)

    def _list_1(self, start: int, end: int) -> list[bytes]:
        return self.contract.functions.list(start, end).call(block_identifier=self.block)

    def name(self, ilk: bytes) -> str:
        return self.contract.functions.name(ilk).call(block_identifier=self.block)

    def pip(self, ilk: bytes) -> str:
        return self.contract.functions.pip(ilk).call(block_identifier=self.block)

    def pos(self, ilk: bytes) -> int:
        return self.contract.functions.pos(ilk).call(block_identifier=self.block)

    @property
    def spot(self) -> str:
        return self.contract.functions.spot().call(block_identifier=self.block)

    def symbol(self, ilk: bytes) -> str:
        return self.contract.functions.symbol(ilk).call(block_identifier=self.block)

    @property
    def vat(self) -> str:
        return self.contract.functions.vat().call(block_identifier=self.block)

    def wards(self, arg0: str) -> int:
        return self.contract.functions.wards(arg0).call(block_identifier=self.block)

    def xlip(self, ilk: bytes) -> str:
        return self.contract.functions.xlip(ilk).call(block_identifier=self.block)


class Vat:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "vat.json"))

    @property
    def line(self) -> int:
        return self.contract.functions.Line().call(block_identifier=self.block)

    def can(self, arg0: str, arg1: str) -> int:
        return self.contract.functions.can(arg0, arg1).call(block_identifier=self.block)

    def dai(self, arg0: str) -> int:
        return self.contract.functions.dai(arg0).call(block_identifier=self.block)

    @property
    def debt(self) -> int:
        return self.contract.functions.debt().call(block_identifier=self.block)

    def gem(self, arg0: bytes, arg1: str) -> int:
        return self.contract.functions.gem(arg0, arg1).call(block_identifier=self.block)

    def ilks(self, arg0: bytes) -> tuple[int, int, int, int, int]:
        """
        Output: Art, rate, spot, line, dust
        """
        return self.contract.functions.ilks(arg0).call(block_identifier=self.block)

    @property
    def live(self) -> int:
        return self.contract.functions.live().call(block_identifier=self.block)

    def sin(self, arg0: str) -> int:
        return self.contract.functions.sin(arg0).call(block_identifier=self.block)

    def urns(self, arg0: bytes, arg1: str) -> tuple[int, int]:
        """
        Output: ink, art
        """
        return self.contract.functions.urns(arg0, arg1).call(block_identifier=self.block)

    @property
    def vice(self) -> int:
        return self.contract.functions.vice().call(block_identifier=self.block)

    def wards(self, arg0: str) -> int:
        return self.contract.functions.wards(arg0).call(block_identifier=self.block)


class McdSpot:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "mcd_spot.json"))

    def ilks(self, arg0: bytes) -> tuple[str, int]:
        """
        Output: pip, mat
        """
        return self.contract.functions.ilks(arg0).call(block_identifier=self.block)

    @property
    def live(self) -> int:
        return self.contract.functions.live().call(block_identifier=self.block)

    @property
    def par(self) -> int:
        return self.contract.functions.par().call(block_identifier=self.block)

    @property
    def vat(self) -> str:
        return self.contract.functions.vat().call(block_identifier=self.block)

    def wards(self, arg0: str) -> int:
        return self.contract.functions.wards(arg0).call(block_identifier=self.block)


class Pot:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "pot.json"))

    @property
    def pie(self) -> int:
        return self.contract.functions.Pie().call(block_identifier=self.block)

    @property
    def chi(self) -> int:
        return self.contract.functions.chi().call(block_identifier=self.block)

    @property
    def drip(self) -> int:
        """
        Output: tmp
        """
        return self.contract.functions.drip().call(block_identifier=self.block)

    @property
    def dsr(self) -> int:
        return self.contract.functions.dsr().call(block_identifier=self.block)

    @property
    def live(self) -> int:
        return self.contract.functions.live().call(block_identifier=self.block)

    def pie_1(self, arg0: str) -> int:
        return self.contract.functions.pie(arg0).call(block_identifier=self.block)

    @property
    def rho(self) -> int:
        return self.contract.functions.rho().call(block_identifier=self.block)

    @property
    def vat(self) -> str:
        return self.contract.functions.vat().call(block_identifier=self.block)

    @property
    def vow(self) -> str:
        return self.contract.functions.vow().call(block_identifier=self.block)

    def wards(self, arg0: str) -> int:
        return self.contract.functions.wards(arg0).call(block_identifier=self.block)


class DsrManager:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "dsr_manager.json"))

    @property
    def dai(self) -> str:
        return self.contract.functions.dai().call(block_identifier=self.block)

    def dai_balance(self, usr: str) -> int:
        """
        Output: wad
        """
        return self.contract.functions.daiBalance(usr).call(block_identifier=self.block)

    @property
    def dai_join(self) -> str:
        return self.contract.functions.daiJoin().call(block_identifier=self.block)

    def pie_of(self, arg0: str) -> int:
        return self.contract.functions.pieOf(arg0).call(block_identifier=self.block)

    @property
    def pot(self) -> str:
        return self.contract.functions.pot().call(block_identifier=self.block)

    @property
    def supply(self) -> int:
        return self.contract.functions.supply().call(block_identifier=self.block)


class Sdai:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "sdai.json"))

    @property
    def domain_separator(self) -> bytes:
        return self.contract.functions.DOMAIN_SEPARATOR().call(block_identifier=self.block)

    @property
    def permit_typehash(self) -> bytes:
        return self.contract.functions.PERMIT_TYPEHASH().call(block_identifier=self.block)

    def allowance(self, arg0: str, arg1: str) -> int:
        return self.contract.functions.allowance(arg0, arg1).call(block_identifier=self.block)

    @property
    def asset(self) -> str:
        return self.contract.functions.asset().call(block_identifier=self.block)

    def balance_of(self, arg0: str) -> int:
        return self.contract.functions.balanceOf(arg0).call(block_identifier=self.block)

    def convert_to_assets(self, shares: int) -> int:
        return self.contract.functions.convertToAssets(shares).call(block_identifier=self.block)

    def convert_to_shares(self, assets: int) -> int:
        return self.contract.functions.convertToShares(assets).call(block_identifier=self.block)

    @property
    def dai(self) -> str:
        return self.contract.functions.dai().call(block_identifier=self.block)

    @property
    def dai_join(self) -> str:
        return self.contract.functions.daiJoin().call(block_identifier=self.block)

    @property
    def decimals(self) -> int:
        return self.contract.functions.decimals().call(block_identifier=self.block)

    @property
    def deployment_chain_id(self) -> int:
        return self.contract.functions.deploymentChainId().call(block_identifier=self.block)

    def max_deposit(self, arg0: str) -> int:
        return self.contract.functions.maxDeposit(arg0).call(block_identifier=self.block)

    def max_mint(self, arg0: str) -> int:
        return self.contract.functions.maxMint(arg0).call(block_identifier=self.block)

    def max_redeem(self, owner: str) -> int:
        return self.contract.functions.maxRedeem(owner).call(block_identifier=self.block)

    def max_withdraw(self, owner: str) -> int:
        return self.contract.functions.maxWithdraw(owner).call(block_identifier=self.block)

    @property
    def name(self) -> str:
        return self.contract.functions.name().call(block_identifier=self.block)

    def nonces(self, arg0: str) -> int:
        return self.contract.functions.nonces(arg0).call(block_identifier=self.block)

    @property
    def pot(self) -> str:
        return self.contract.functions.pot().call(block_identifier=self.block)

    def preview_deposit(self, assets: int) -> int:
        return self.contract.functions.previewDeposit(assets).call(block_identifier=self.block)

    def preview_mint(self, shares: int) -> int:
        return self.contract.functions.previewMint(shares).call(block_identifier=self.block)

    def preview_redeem(self, shares: int) -> int:
        return self.contract.functions.previewRedeem(shares).call(block_identifier=self.block)

    def preview_withdraw(self, assets: int) -> int:
        return self.contract.functions.previewWithdraw(assets).call(block_identifier=self.block)

    @property
    def symbol(self) -> str:
        return self.contract.functions.symbol().call(block_identifier=self.block)

    @property
    def total_assets(self) -> int:
        return self.contract.functions.totalAssets().call(block_identifier=self.block)

    @property
    def total_supply(self) -> int:
        return self.contract.functions.totalSupply().call(block_identifier=self.block)

    @property
    def vat(self) -> str:
        return self.contract.functions.vat().call(block_identifier=self.block)

    @property
    def version(self) -> str:
        return self.contract.functions.version().call(block_identifier=self.block)


class Iou:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "iou.json"))

    def allowance(self, arg0: str, arg1: str) -> int:
        return self.contract.functions.allowance(arg0, arg1).call(block_identifier=self.block)

    @property
    def authority(self) -> str:
        return self.contract.functions.authority().call(block_identifier=self.block)

    def balance_of(self, arg0: str) -> int:
        return self.contract.functions.balanceOf(arg0).call(block_identifier=self.block)

    @property
    def decimals(self) -> int:
        return self.contract.functions.decimals().call(block_identifier=self.block)

    @property
    def name(self) -> bytes:
        return self.contract.functions.name().call(block_identifier=self.block)

    @property
    def owner(self) -> str:
        return self.contract.functions.owner().call(block_identifier=self.block)

    @property
    def stopped(self) -> bool:
        return self.contract.functions.stopped().call(block_identifier=self.block)

    @property
    def symbol(self) -> bytes:
        return self.contract.functions.symbol().call(block_identifier=self.block)

    @property
    def total_supply(self) -> int:
        return self.contract.functions.totalSupply().call(block_identifier=self.block)
