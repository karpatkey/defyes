import logging
from contextlib import suppress
from decimal import Decimal
from typing import Tuple

from defabipedia import Chain
from defabipedia.tokens import EthereumTokenAddr, GnosisTokenAddr
from karpatkit.constants import Address
from karpatkit.node import get_node
from web3 import Web3

from defyes.functions import balance_of, ensure_a_block_number
from defyes.protocols.maker.autogenerated import (
    CdpManager,
    DsrManager,
    IlkRegistry,
    Iou,
    McdSpot,
    Pot,
    ProxyRegistry,
    Sdai,
    Vat,
)
from defyes.types import Token, TokenAmount

logger = logging.getLogger(__name__)


class ProxyRegistry(ProxyRegistry):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4",
    }


class CdpManager(CdpManager):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x5ef30b9986345249bc32d8928B7ee64DE9435E39",
    }

    def get_vault_ids(self, proxy_addr: str) -> list[int]:
        ids = []
        n_id = self.first(proxy_addr)
        for nvault in range(self.count(proxy_addr)):
            ids.append(n_id)
            n_id = self._list(n_id)[1]
        return ids


class IlkRegistry(IlkRegistry):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x5a464C28D19848f44199D003BeF5ecc87d090F87",
    }


class Vat(Vat):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
    }


class McdSpot(McdSpot):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3",
    }


class Pot(Pot):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
    }

    @property
    def chi(self):
        ts = self.contract.w3.eth.get_block(self.block)["timestamp"]
        if ts > self.rho:
            chi = self.drip
        else:
            chi = self.chi
        return chi


class DsrManager(DsrManager):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x373238337Bfe1146fb49989fc222523f83081dDb",
    }


class Sdai(Sdai):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x83F20F44975D03b1b09e64809B757c47f942BEeA",
        Chain.GNOSIS: "0xaf204776c7245bF4147c2612BF6e5972Ee483701",
    }

    @property
    def dai(self) -> str:
        if self.blockchain == Chain.GNOSIS:
            return Address.ZERO  # If called on gnosis, return 0x0
        else:
            return super().dai


class Iou(Iou):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0xA618E54de493ec29432EbD2CA7f14eFbF6Ac17F7",
    }


# TODO: deprecate
def get_vault_data(vault_id: int, block: int | str) -> list:
    cdp_manager = CdpManager(Chain.ETHEREUM, block)
    ilk_registry = IlkRegistry(Chain.ETHEREUM, block)
    vat = Vat(Chain.ETHEREUM, block)
    spot = McdSpot(Chain.ETHEREUM, block)

    ilk = cdp_manager.ilks(vault_id)
    ilk_info = ilk_registry.info(ilk)
    urn_handler_address = cdp_manager.urns(vault_id)
    urn_data = vat.urns(ilk, urn_handler_address)
    ilk_data = vat.ilks(ilk)

    vault_data = {
        "mat": spot.ilks(ilk)[1] / Decimal(10**27),
        "gem": ilk_info[4],
        "dai": EthereumTokenAddr.DAI,
        "ink": urn_data[0] / Decimal(10**18),
        "art": urn_data[1] / Decimal(10**18),
        "Art": ilk_data[0] / Decimal(10**18),
        "rate": ilk_data[1] / Decimal(10**27),
        "spot": ilk_data[2] / Decimal(10**27),
        "line": ilk_data[3] / Decimal(10**45),
        "dust": ilk_data[4] / Decimal(10**45),
    }

    return vault_data


# TODO: deprecate
def underlying(vault_id: int, block: int | str) -> tuple[list]:
    """
    Output:
    1 - Tuple: [[collateral_address, collateral_amount], [debt_address, -debt_amount]]
    """
    result = []

    vault_data = get_vault_data(vault_id, block)

    # Append the Collateral Address and Balance to result[]
    result.append([vault_data["gem"], vault_data["ink"]])

    # Append the Debt Address (DAI Address) and Balance to result[]
    total_debt = (vault_data["art"] * vault_data["rate"]) * -1
    result.append([vault_data["dai"], total_debt])

    return result


# TODO: deprecate
def get_delegated_MKR(wallet: str, block: int | str, web3=None, decimals=True) -> int | float:
    if web3 is None:
        web3 = get_node(Chain.ETHEREUM)

    IOU_token_address = "0xA618E54de493ec29432EbD2CA7f14eFbF6Ac17F7"
    balance = balance_of(wallet, IOU_token_address, block, Chain.ETHEREUM, web3=web3, decimals=decimals)
    return [[EthereumTokenAddr.MKR, balance]]


def get_protocol_data_for(
    blockchain: str, wallet: str, lptoken_address: str, block: int | str = "latest", decimals: bool = True
) -> dict:
    block_id = ensure_a_block_number(block, blockchain)
    wallet = Web3.to_checksum_address(wallet)

    data = {"holdings": [], "underlyings": [], "rewards": [], "financial_metrics": {}}
    with suppress(ValueError):
        vault_id = int(lptoken_address)
        proxy = ProxyRegistry(blockchain, block_id)
        proxy_addr = proxy.proxies(wallet)
        cdp = CdpManager(blockchain, block_id)
        vault_ids = cdp.get_vault_ids(proxy_addr)
        if vault_id in vault_ids:
            ilk_registry = IlkRegistry(blockchain, block_id)
            vat = Vat(blockchain, block_id)
            ilk = cdp.ilks(vault_id)
            ilk_info = ilk_registry.info(ilk)
            urn_handler_address = cdp.urns(vault_id)
            urn_data = vat.urns(ilk, urn_handler_address)
            ilk_data = vat.ilks(ilk)

            gem = ilk_info[4]
            ink = urn_data[0] / Decimal(10**18 if decimals else 1)
            art = urn_data[1] / Decimal(10**18)
            rate = ilk_data[1] / Decimal(10**27)
            balance = -1 * art * rate * Decimal(1 if decimals else 10**18)

            token = Token.get_instance(gem, Chain.ETHEREUM, block_id)
            token_dai = Token.get_instance(EthereumTokenAddr.DAI, Chain.ETHEREUM, block_id)
            data["underlyings"] = [TokenAmount(ink, token), TokenAmount(balance, token_dai)]
            return data
        else:
            raise ValueError(f"Wallet {wallet} does not have vault id: {vault_id}")

    if lptoken_address == "na":
        iou = Iou(blockchain, block_id)
        balance = iou.balance_of(wallet)
        token = Token.get_instance(EthereumTokenAddr.MKR, Chain.ETHEREUM, block_id)
        data["underlyings"] = [TokenAmount.from_teu(balance, token)]
        return data

    lptoken_address = Web3.to_checksum_address(lptoken_address)
    if lptoken_address in ["0x83F20F44975D03b1b09e64809B757c47f942BEeA", "0xaf204776c7245bF4147c2612BF6e5972Ee483701"]:
        sdai = Sdai(blockchain, block_id)
        sdai_balance = sdai.balance_of(wallet)
        balance = int(sdai.convert_to_assets(sdai_balance))
        if blockchain == Chain.ETHEREUM:
            token = Token.get_instance(EthereumTokenAddr.DAI, blockchain, block_id)
        if blockchain == Chain.GNOSIS:
            token = Token.get_instance(GnosisTokenAddr.DAI, blockchain, block_id)
        data["underlyings"] = [TokenAmount.from_teu(balance, token)]
        return data

    if lptoken_address == "0x373238337Bfe1146fb49989fc222523f83081dDb":
        dsr = DsrManager(blockchain, block_id)
        pot = Pot(blockchain, block_id)
        balance = Decimal(dsr.pie_of(wallet) * pot.chi) / Decimal(1e18) / Decimal(1e27)
        token = Token.get_instance(EthereumTokenAddr.DAI, Chain.ETHEREUM, block_id)
        data["underlyings"] = [TokenAmount(balance, token)]
        return data
    return data


def get_protocol_data(blockchain: str, wallet: str, block: int | str = "latest", decimals: bool = True) -> dict:
    """
    TODO: Add documentation
    """
    wallet = Web3.to_checksum_address(wallet)
    block_id = ensure_a_block_number(block, blockchain)
    positions = {}

    proxy = ProxyRegistry(blockchain, block_id)
    cdp = CdpManager(blockchain, block_id)
    ilk_registry = IlkRegistry(blockchain, block_id)
    vat = Vat(blockchain, block_id)
    dsr = DsrManager(blockchain, block_id)
    pot = Pot(blockchain, block_id)

    proxy_addr = proxy.proxies(wallet)
    vault_ids = cdp.get_vault_ids(proxy_addr)
    for vault_id in vault_ids:
        positions["vaults"] = positions.get("vaults", {})
        ilk = cdp.ilks(vault_id)
        ilk_info = ilk_registry.info(ilk)
        urn_handler_address = cdp.urns(vault_id)
        urn_data = vat.urns(ilk, urn_handler_address)
        ilk_data = vat.ilks(ilk)

        gem = ilk_info[4]
        ink = urn_data[0] / Decimal(10**18 if decimals else 1)
        art = urn_data[1] / Decimal(10**18)
        rate = ilk_data[1] / Decimal(10**27)

        positions["vaults"][vault_id] = {
            "liquidity": {
                "underlyings": [
                    {"address": gem, "balance": ink},
                    {
                        "address": EthereumTokenAddr.DAI,
                        "balance": -1 * art * rate * Decimal(1 if decimals else 10**18),
                    },
                ]
            }
        }

    dsr_balance = Decimal(dsr.pie_of(wallet) * pot.chi) / Decimal(1e18) / Decimal(1e27)
    positions["mananger"] = {
        "liquidity": {
            "underlyings": [
                {"address": EthereumTokenAddr.DAI, "balance": dsr_balance * Decimal(1 if decimals else 10**18)},
            ]
        }
    }

    pot_balance = Decimal(pot.pie_1(wallet) * pot.chi) / Decimal(1e18) / Decimal(1e27)
    positions["pot"] = {
        "liquidity": {
            "underlyings": [
                {"address": EthereumTokenAddr.DAI, "balance": pot_balance * Decimal(1 if decimals else 10**18)},
            ]
        }
    }
    return {
        "protocol": "Maker",
        "blockchain": blockchain,
        "wallet": Web3.to_checksum_address(wallet),
        "block_id": block_id,
        "positions_key": None,
        "positions": positions,
        "version": 0,
    }


def reduce_sdai(
    underlying_token_address: str, balance: int | float | TokenAmount, block: int, blockchain: Chain, teu: bool = False
) -> Tuple[str, Decimal]:
    """Reduce sDAI to the elementary asset DAI in ethereum and gnosis
    Returns:
        Tuple: (underlying_token_address, underlying_balance)
    """
    block = ensure_a_block_number(block, blockchain)
    underlying_token_address = Web3.to_checksum_address(underlying_token_address)

    if underlying_token_address not in [Sdai(Chain.ETHEREUM, block).address, Sdai(Chain.GNOSIS, block).address]:
        raise ValueError(f"Token address {underlying_token_address} is not a valid sDAI address.")

    sdai_contract = Sdai(blockchain, block)
    sdai_token = Token(sdai_contract.address, blockchain, block)

    # In case the amount is in teu just convert it to ETH else convert it to teu and then to ETH
    if teu:
        dai_balance = sdai_contract.convert_to_assets(int(balance))
        dai_balance = TokenAmount.from_teu(dai_balance, sdai_token).balance(True)

    else:
        dai_balance = TokenAmount(balance, sdai_token).balance()
        dai_balance = sdai_contract.convert_to_assets(int(dai_balance))
        dai_balance = TokenAmount.from_teu(dai_balance, sdai_contract).balance(True)

    unwrapped_token_address = sdai_contract.dai

    return unwrapped_token_address, dai_balance
