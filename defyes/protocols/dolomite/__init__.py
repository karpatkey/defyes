import json
import os
from pathlib import Path

from defabipedia import Chain
from defabipedia.dolomite import ArbitrumContractSpecs
from web3 import Web3

from defyes.functions import ensure_a_block_number, get_logs_web3
from defyes.protocols.dolomite.autogenerated import DarbIsolation, DolomiteMargin
from defyes.types import Token, TokenAmount

DB_FILE = Path(__file__).parent / "db.json"

BORROW_PROXYV2_ADDRESS = ArbitrumContractSpecs.BorrowProxyV2.address
DOLOMITE_MARGIN_ADDRESS = ArbitrumContractSpecs.DolomiteMargin.address

DolomiteMargin.default_addresses = {Chain.ARBITRUM: DOLOMITE_MARGIN_ADDRESS}


class DolomiteDatabaseManager:
    def __init__(self):
        self.filename = DB_FILE
        self.topic0 = "0xfd9156bd20ce24a786c761efe71a3931de038c1f2620c1bb4720609bc742b58e"

    def get_data_from_db(self):
        with open(self.filename, "r") as f:
            return json.load(f)

    def update_database_accounts(
        self,
        blockchain: str | Chain,
        wallet_address: str,
        block_start: int,
        account_address: str = None,
        isolation_address: str = None,
    ):
        """Update the db.json file.
        In order to not run through the whole blockchain, the function will
        look for logs in the blockchain from the input start_block(where the transaction has been made or right before)
        to start_block + 100. It then updates the db.json file with the new data.
        You can provide either the dolomite account_address to look for or the isolation_address to look for the account.

        Args:
            blockchain (str): The blockchain to look for the logs.
            wallet_address (str): The address of the wallet that is going to be saved.
            account_address (str): The address of the account that is going to be saved.
            block_start (int): The block where the transaction has been made or right before.
            isolation_address (str): The address of the isolation mode contract. Default is None.
        """
        if wallet_address is None and account_address is None:
            raise ValueError("At least one of wallet_address or account_address must be provided")

        logs = get_logs_web3(
            blockchain, block_start=block_start, block_end=block_start + 100, address=BORROW_PROXYV2_ADDRESS
        )

        if isolation_address:
            account_address = DarbIsolation(blockchain, block_start, isolation_address).get_vault_by_account(
                wallet_address
            )

        filtered_data = self._filter_logs_by_topic(logs, account_address, wallet_address, isolation_address)
        self._append_to_json_file(filtered_data)

    def _append_to_json_file(self, data):
        """Create or append data to a json file storing the addresses and numbers of the dolomite accounts.
        Default filename is db.json inside the dolomite folder."""
        if os.path.exists(self.filename):
            current_data = self.get_data_from_db()
        else:
            current_data = []

        current_data.append(data)
        # To avoiod duplicates convert the data to a set and then back to a list
        current_data = set(map(json.dumps, current_data))
        current_data = list(map(json.loads, current_data))

        with open(self.filename, "w") as f:
            json.dump(current_data, f)

    def _filter_logs_by_topic(self, logs, account_address: str, wallet_address: str):
        """Look for logs with the topic0 and address provided to save the info of the dolomite accounts."""
        topics_dict = {}

        for log in logs:
            if log["topics"][0].hex() == self.topic0 and "0x" + log["topics"][1].hex()[-40:] == account_address:
                topics_dict["wallet_address"] = Web3.to_checksum_address(wallet_address)
                topics_dict["account_address"] = Web3.to_checksum_address(account_address)
                topics_dict["account_number"] = Web3.to_int(hexstr=logs[0]["topics"][2].hex())

        return topics_dict


def get_protocol_data_for(
    blockchain: str,
    wallet: str,
    block: int | str = "latest",
    decimals: bool = True,
) -> dict:
    """Get Dolomite protocol data for a specific blockchain, wallet, and block.

    Args:
        blockchain (str): The blockchain to interact with.
        wallet (str): The address of the wallet to get the data for.
        block (int | str, optional): The block number or "latest". Defaults to "latest".
        decimals (bool, optional): Whether to show balances with decimals. Defaults to True.

    Raises:
        ValueError: If the specified blockchain is not supported. Or If no positions are found for the wallet.

    Returns:
        dict: A dictionary containing the protocol data.
    """
    if blockchain != Chain.ARBITRUM:
        raise ValueError("Only Arbitrum is supported for now.")

    wallet = Web3.to_checksum_address(wallet)
    block = ensure_a_block_number(block, blockchain)

    # Initialize data
    data = {
        "blockchain": blockchain,
        "block": block,
        "protocol": "Dolomite",
        "positions_key": "position_type",
        "version": 0,
        "wallet": wallet,
        "decimals": 18,
    }

    positions = {}

    # Initialize DolomiteMargin contract to get the positions
    dolomite_margin = DolomiteMargin(blockchain, block)

    # Check if there's any balance deposited from the wallet and store them as underlyings
    account = {"owner": wallet, "number": 0}
    balances = dolomite_margin.get_account_balances(account)

    deposits = []
    for i in range(len(balances[0])):
        # In case decimals is True, the amount is shown as
        if decimals:
            balance = TokenAmount.from_teu(balances[3][i][1], Token(balances[1][i], blockchain)).balance(decimals)
        else:
            balance = balances[3][i][1]

        deposits.append({"underlyings": [{"address": balances[1][i], "balance": balance}]})
    positions["deposits"] = deposits

    # Check if the wallet is in the database and has any other position
    db_manager = DolomiteDatabaseManager()
    db_data = db_manager.get_data_from_db()

    for pos in db_data:
        underlyings = []
        if pos["wallet_address"] == wallet:
            account = {"owner": pos["account_address"], "number": pos["account_number"]}
            balances = dolomite_margin.get_account_balances(account)
            # In case the amount is borrowed (False), the amount is shown as negative
            for i in range(len(balances[0])):
                if decimals:
                    amount = TokenAmount.from_teu(balances[3][i][1], Token(balances[1][i], blockchain)).balance(
                        decimals
                    )
                else:
                    amount = balances[3][i][1]

                if balances[3][i][0] is False:
                    amount = -(amount)

                underlyings.append({"address": balances[1][i], "balance": amount})

        positions["isolation"] = underlyings

    if not positions:
        raise ValueError("No positions found for the wallet. Check address or update database.")

    data["positions"] = positions

    return data
