"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import Steth, Wsteth, Unsteth

# Optionally
class Steth(Steth):
    ...
"""

from karpatkit.node import get_node
from web3 import Web3

from defyes.generator import load_abi


class Steth:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "steth.json"))

    @property
    def name(self) -> str:
        return self.contract.functions.name().call(block_identifier=self.block)

    @property
    def has_initialized(self) -> bool:
        return self.contract.functions.hasInitialized().call(block_identifier=self.block)

    @property
    def staking_control_role(self) -> bytes:
        return self.contract.functions.STAKING_CONTROL_ROLE().call(block_identifier=self.block)

    @property
    def total_supply(self) -> int:
        return self.contract.functions.totalSupply().call(block_identifier=self.block)

    def get_shares_by_pooled_eth(self, _eth_amount: int) -> int:
        return self.contract.functions.getSharesByPooledEth(_eth_amount).call(block_identifier=self.block)

    @property
    def is_staking_paused(self) -> bool:
        return self.contract.functions.isStakingPaused().call(block_identifier=self.block)

    def get_evm_script_executor(self, _script: bytes) -> str:
        return self.contract.functions.getEVMScriptExecutor(_script).call(block_identifier=self.block)

    @property
    def resume_role(self) -> bytes:
        return self.contract.functions.RESUME_ROLE().call(block_identifier=self.block)

    @property
    def decimals(self) -> int:
        return self.contract.functions.decimals().call(block_identifier=self.block)

    @property
    def get_recovery_vault(self) -> str:
        return self.contract.functions.getRecoveryVault().call(block_identifier=self.block)

    @property
    def domain_separator(self) -> bytes:
        return self.contract.functions.DOMAIN_SEPARATOR().call(block_identifier=self.block)

    @property
    def get_total_pooled_ether(self) -> int:
        return self.contract.functions.getTotalPooledEther().call(block_identifier=self.block)

    @property
    def pause_role(self) -> bytes:
        return self.contract.functions.PAUSE_ROLE().call(block_identifier=self.block)

    @property
    def get_treasury(self) -> str:
        return self.contract.functions.getTreasury().call(block_identifier=self.block)

    @property
    def is_stopped(self) -> bool:
        return self.contract.functions.isStopped().call(block_identifier=self.block)

    @property
    def get_buffered_ether(self) -> int:
        return self.contract.functions.getBufferedEther().call(block_identifier=self.block)

    def initialize(self, _lido_locator: str, _eip712_st_eth: str):
        return self.contract.functions.initialize(_lido_locator, _eip712_st_eth).call(block_identifier=self.block)

    @property
    def receive_el_rewards(self):
        return self.contract.functions.receiveELRewards().call(block_identifier=self.block)

    @property
    def get_withdrawal_credentials(self) -> bytes:
        return self.contract.functions.getWithdrawalCredentials().call(block_identifier=self.block)

    @property
    def get_current_stake_limit(self) -> int:
        return self.contract.functions.getCurrentStakeLimit().call(block_identifier=self.block)

    @property
    def get_stake_limit_full_info(self) -> tuple[bool, bool, int, int, int, int, int]:
        """
        Output: isStakingPaused, isStakingLimitSet, currentStakeLimit,
        maxStakeLimit, maxStakeLimitGrowthBlocks, prevStakeLimit,
        prevStakeBlockNumber
        """
        return self.contract.functions.getStakeLimitFullInfo().call(block_identifier=self.block)

    def balance_of(self, _account: str) -> int:
        return self.contract.functions.balanceOf(_account).call(block_identifier=self.block)

    @property
    def get_fee_distribution(self) -> tuple[int, int, int]:
        """
        Output: treasuryFeeBasisPoints, insuranceFeeBasisPoints,
        operatorsFeeBasisPoints
        """
        return self.contract.functions.getFeeDistribution().call(block_identifier=self.block)

    @property
    def receive_withdrawals(self):
        return self.contract.functions.receiveWithdrawals().call(block_identifier=self.block)

    def get_pooled_eth_by_shares(self, _shares_amount: int) -> int:
        return self.contract.functions.getPooledEthByShares(_shares_amount).call(block_identifier=self.block)

    def allow_recoverability(self, token: str) -> bool:
        return self.contract.functions.allowRecoverability(token).call(block_identifier=self.block)

    def nonces(self, owner: str) -> int:
        return self.contract.functions.nonces(owner).call(block_identifier=self.block)

    @property
    def app_id(self) -> bytes:
        return self.contract.functions.appId().call(block_identifier=self.block)

    @property
    def get_oracle(self) -> str:
        return self.contract.functions.getOracle().call(block_identifier=self.block)

    @property
    def eip712_domain(self) -> tuple[str, str, int, str]:
        """
        Output: name, version, chainId, verifyingContract
        """
        return self.contract.functions.eip712Domain().call(block_identifier=self.block)

    @property
    def get_contract_version(self) -> int:
        return self.contract.functions.getContractVersion().call(block_identifier=self.block)

    @property
    def get_initialization_block(self) -> int:
        return self.contract.functions.getInitializationBlock().call(block_identifier=self.block)

    @property
    def symbol(self) -> str:
        return self.contract.functions.symbol().call(block_identifier=self.block)

    @property
    def get_eip712_st_eth(self) -> str:
        return self.contract.functions.getEIP712StETH().call(block_identifier=self.block)

    def can_perform(self, _sender: str, _role: bytes, _params: list[int]) -> bool:
        return self.contract.functions.canPerform(_sender, _role, _params).call(block_identifier=self.block)

    def submit(self, _referral: str) -> int:
        return self.contract.functions.submit(_referral).call(block_identifier=self.block)

    @property
    def get_evm_script_registry(self) -> str:
        return self.contract.functions.getEVMScriptRegistry().call(block_identifier=self.block)

    @property
    def unsafe_change_deposited_validators_role(self) -> bytes:
        return self.contract.functions.UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE().call(block_identifier=self.block)

    @property
    def get_beacon_stat(self) -> tuple[int, int, int]:
        """
        Output: depositedValidators, beaconValidators, beaconBalance
        """
        return self.contract.functions.getBeaconStat().call(block_identifier=self.block)

    @property
    def get_fee(self) -> int:
        """
        Output: totalFee
        """
        return self.contract.functions.getFee().call(block_identifier=self.block)

    @property
    def kernel(self) -> str:
        return self.contract.functions.kernel().call(block_identifier=self.block)

    @property
    def get_total_shares(self) -> int:
        return self.contract.functions.getTotalShares().call(block_identifier=self.block)

    def allowance(self, _owner: str, _spender: str) -> int:
        return self.contract.functions.allowance(_owner, _spender).call(block_identifier=self.block)

    @property
    def is_petrified(self) -> bool:
        return self.contract.functions.isPetrified().call(block_identifier=self.block)

    @property
    def get_lido_locator(self) -> str:
        return self.contract.functions.getLidoLocator().call(block_identifier=self.block)

    @property
    def can_deposit(self) -> bool:
        return self.contract.functions.canDeposit().call(block_identifier=self.block)

    @property
    def staking_pause_role(self) -> bytes:
        return self.contract.functions.STAKING_PAUSE_ROLE().call(block_identifier=self.block)

    @property
    def get_depositable_ether(self) -> int:
        return self.contract.functions.getDepositableEther().call(block_identifier=self.block)

    def shares_of(self, _account: str) -> int:
        return self.contract.functions.sharesOf(_account).call(block_identifier=self.block)

    @property
    def get_total_el_rewards_collected(self) -> int:
        return self.contract.functions.getTotalELRewardsCollected().call(block_identifier=self.block)


class Wsteth:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "wsteth.json"))

    @property
    def domain_separator(self) -> bytes:
        return self.contract.functions.DOMAIN_SEPARATOR().call(block_identifier=self.block)

    def allowance(self, owner: str, spender: str) -> int:
        return self.contract.functions.allowance(owner, spender).call(block_identifier=self.block)

    def balance_of(self, account: str) -> int:
        return self.contract.functions.balanceOf(account).call(block_identifier=self.block)

    @property
    def decimals(self) -> int:
        return self.contract.functions.decimals().call(block_identifier=self.block)

    def get_st_eth_by_wst_eth(self, _wst_eth_amount: int) -> int:
        return self.contract.functions.getStETHByWstETH(_wst_eth_amount).call(block_identifier=self.block)

    def get_wst_eth_by_st_eth(self, _st_eth_amount: int) -> int:
        return self.contract.functions.getWstETHByStETH(_st_eth_amount).call(block_identifier=self.block)

    @property
    def name(self) -> str:
        return self.contract.functions.name().call(block_identifier=self.block)

    def nonces(self, owner: str) -> int:
        return self.contract.functions.nonces(owner).call(block_identifier=self.block)

    @property
    def st_eth(self) -> str:
        return self.contract.functions.stETH().call(block_identifier=self.block)

    @property
    def st_eth_per_token(self) -> int:
        return self.contract.functions.stEthPerToken().call(block_identifier=self.block)

    @property
    def symbol(self) -> str:
        return self.contract.functions.symbol().call(block_identifier=self.block)

    @property
    def tokens_per_st_eth(self) -> int:
        return self.contract.functions.tokensPerStEth().call(block_identifier=self.block)

    @property
    def total_supply(self) -> int:
        return self.contract.functions.totalSupply().call(block_identifier=self.block)


class Unsteth:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "unsteth.json"))

    @property
    def bunker_mode_disabled_timestamp(self) -> int:
        return self.contract.functions.BUNKER_MODE_DISABLED_TIMESTAMP().call(block_identifier=self.block)

    @property
    def default_admin_role(self) -> bytes:
        return self.contract.functions.DEFAULT_ADMIN_ROLE().call(block_identifier=self.block)

    @property
    def finalize_role(self) -> bytes:
        return self.contract.functions.FINALIZE_ROLE().call(block_identifier=self.block)

    @property
    def manage_token_uri_role(self) -> bytes:
        return self.contract.functions.MANAGE_TOKEN_URI_ROLE().call(block_identifier=self.block)

    @property
    def max_batches_length(self) -> int:
        return self.contract.functions.MAX_BATCHES_LENGTH().call(block_identifier=self.block)

    @property
    def max_steth_withdrawal_amount(self) -> int:
        return self.contract.functions.MAX_STETH_WITHDRAWAL_AMOUNT().call(block_identifier=self.block)

    @property
    def min_steth_withdrawal_amount(self) -> int:
        return self.contract.functions.MIN_STETH_WITHDRAWAL_AMOUNT().call(block_identifier=self.block)

    @property
    def oracle_role(self) -> bytes:
        return self.contract.functions.ORACLE_ROLE().call(block_identifier=self.block)

    @property
    def pause_infinitely(self) -> int:
        return self.contract.functions.PAUSE_INFINITELY().call(block_identifier=self.block)

    @property
    def pause_role(self) -> bytes:
        return self.contract.functions.PAUSE_ROLE().call(block_identifier=self.block)

    @property
    def resume_role(self) -> bytes:
        return self.contract.functions.RESUME_ROLE().call(block_identifier=self.block)

    @property
    def steth(self) -> str:
        return self.contract.functions.STETH().call(block_identifier=self.block)

    @property
    def wsteth(self) -> str:
        return self.contract.functions.WSTETH().call(block_identifier=self.block)

    def balance_of(self, _owner: str) -> int:
        return self.contract.functions.balanceOf(_owner).call(block_identifier=self.block)

    @property
    def bunker_mode_since_timestamp(self) -> int:
        return self.contract.functions.bunkerModeSinceTimestamp().call(block_identifier=self.block)

    def calculate_finalization_batches(
        self, _max_share_rate: int, _max_timestamp: int, _max_requests_per_call: int, _state: tuple
    ) -> tuple:
        return self.contract.functions.calculateFinalizationBatches(
            _max_share_rate, _max_timestamp, _max_requests_per_call, _state
        ).call(block_identifier=self.block)

    def finalize(self, _last_request_id_to_be_finalized: int, _max_share_rate: int):
        return self.contract.functions.finalize(_last_request_id_to_be_finalized, _max_share_rate).call(
            block_identifier=self.block
        )

    def find_checkpoint_hints(self, _request_ids: list[int], _first_index: int, _last_index: int) -> list[int]:
        """
        Output: hintIds
        """
        return self.contract.functions.findCheckpointHints(_request_ids, _first_index, _last_index).call(
            block_identifier=self.block
        )

    def get_approved(self, _request_id: int) -> str:
        return self.contract.functions.getApproved(_request_id).call(block_identifier=self.block)

    @property
    def get_base_uri(self) -> str:
        return self.contract.functions.getBaseURI().call(block_identifier=self.block)

    def get_claimable_ether(self, _request_ids: list[int], _hints: list[int]) -> list[int]:
        """
        Output: claimableEthValues
        """
        return self.contract.functions.getClaimableEther(_request_ids, _hints).call(block_identifier=self.block)

    @property
    def get_contract_version(self) -> int:
        return self.contract.functions.getContractVersion().call(block_identifier=self.block)

    @property
    def get_last_checkpoint_index(self) -> int:
        return self.contract.functions.getLastCheckpointIndex().call(block_identifier=self.block)

    @property
    def get_last_finalized_request_id(self) -> int:
        return self.contract.functions.getLastFinalizedRequestId().call(block_identifier=self.block)

    @property
    def get_last_request_id(self) -> int:
        return self.contract.functions.getLastRequestId().call(block_identifier=self.block)

    @property
    def get_locked_ether_amount(self) -> int:
        return self.contract.functions.getLockedEtherAmount().call(block_identifier=self.block)

    @property
    def get_nft_descriptor_address(self) -> str:
        return self.contract.functions.getNFTDescriptorAddress().call(block_identifier=self.block)

    @property
    def get_resume_since_timestamp(self) -> int:
        return self.contract.functions.getResumeSinceTimestamp().call(block_identifier=self.block)

    def get_role_admin(self, role: bytes) -> bytes:
        return self.contract.functions.getRoleAdmin(role).call(block_identifier=self.block)

    def get_role_member(self, role: bytes, index: int) -> str:
        return self.contract.functions.getRoleMember(role, index).call(block_identifier=self.block)

    def get_role_member_count(self, role: bytes) -> int:
        return self.contract.functions.getRoleMemberCount(role).call(block_identifier=self.block)

    def get_withdrawal_requests(self, _owner: str) -> list[int]:
        """
        Output: requestsIds
        """
        return self.contract.functions.getWithdrawalRequests(_owner).call(block_identifier=self.block)

    def get_withdrawal_status(self, _request_ids: list[int]) -> list[tuple]:
        """
        Output: statuses
        """
        return self.contract.functions.getWithdrawalStatus(_request_ids).call(block_identifier=self.block)

    def has_role(self, role: bytes, account: str) -> bool:
        return self.contract.functions.hasRole(role, account).call(block_identifier=self.block)

    def is_approved_for_all(self, _owner: str, _operator: str) -> bool:
        return self.contract.functions.isApprovedForAll(_owner, _operator).call(block_identifier=self.block)

    @property
    def is_bunker_mode_active(self) -> bool:
        return self.contract.functions.isBunkerModeActive().call(block_identifier=self.block)

    @property
    def is_paused(self) -> bool:
        return self.contract.functions.isPaused().call(block_identifier=self.block)

    @property
    def name(self) -> str:
        return self.contract.functions.name().call(block_identifier=self.block)

    def owner_of(self, _request_id: int) -> str:
        return self.contract.functions.ownerOf(_request_id).call(block_identifier=self.block)

    def prefinalize(self, _batches: list[int], _max_share_rate: int) -> tuple[int, int]:
        """
        Output: ethToLock, sharesToBurn
        """
        return self.contract.functions.prefinalize(_batches, _max_share_rate).call(block_identifier=self.block)

    def supports_interface(self, interface_id: bytes) -> bool:
        return self.contract.functions.supportsInterface(interface_id).call(block_identifier=self.block)

    @property
    def symbol(self) -> str:
        return self.contract.functions.symbol().call(block_identifier=self.block)

    def token_uri(self, _request_id: int) -> str:
        return self.contract.functions.tokenURI(_request_id).call(block_identifier=self.block)

    @property
    def unfinalized_request_number(self) -> int:
        return self.contract.functions.unfinalizedRequestNumber().call(block_identifier=self.block)

    @property
    def unfinalized_st_eth(self) -> int:
        return self.contract.functions.unfinalizedStETH().call(block_identifier=self.block)
