"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import Distributor

# Optionally
class Distributor(Distributor):
    ...
"""

from karpatkit.node import get_node
from web3 import Web3

from defyes.generator import load_abi


class Distributor:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "distributor.json"))

    def can_update_merkle_root(self, arg0: str) -> int:
        return self.contract.functions.canUpdateMerkleRoot(arg0).call(block_identifier=self.block)

    def claimed(self, arg0: str, arg1: str) -> tuple[int, int, bytes]:
        """
        Output: amount, timestamp, merkleRoot
        """
        return self.contract.functions.claimed(arg0, arg1).call(block_identifier=self.block)

    @property
    def core(self) -> str:
        return self.contract.functions.core().call(block_identifier=self.block)

    @property
    def dispute_amount(self) -> int:
        return self.contract.functions.disputeAmount().call(block_identifier=self.block)

    @property
    def dispute_period(self) -> int:
        return self.contract.functions.disputePeriod().call(block_identifier=self.block)

    @property
    def dispute_token(self) -> str:
        return self.contract.functions.disputeToken().call(block_identifier=self.block)

    @property
    def disputer(self) -> str:
        return self.contract.functions.disputer().call(block_identifier=self.block)

    @property
    def end_of_dispute_period(self) -> int:
        return self.contract.functions.endOfDisputePeriod().call(block_identifier=self.block)

    @property
    def get_merkle_root(self) -> bytes:
        return self.contract.functions.getMerkleRoot().call(block_identifier=self.block)

    @property
    def last_tree(self) -> tuple[bytes, bytes]:
        """
        Output: merkleRoot, ipfsHash
        """
        return self.contract.functions.lastTree().call(block_identifier=self.block)

    def only_operator_can_claim(self, arg0: str) -> int:
        return self.contract.functions.onlyOperatorCanClaim(arg0).call(block_identifier=self.block)

    def operators(self, arg0: str, arg1: str) -> int:
        return self.contract.functions.operators(arg0, arg1).call(block_identifier=self.block)

    @property
    def proxiable_uuid(self) -> bytes:
        return self.contract.functions.proxiableUUID().call(block_identifier=self.block)

    @property
    def tree(self) -> tuple[bytes, bytes]:
        """
        Output: merkleRoot, ipfsHash
        """
        return self.contract.functions.tree().call(block_identifier=self.block)

    def upgrade_to_and_call(self, new_implementation: str, data: bytes):
        return self.contract.functions.upgradeToAndCall(new_implementation, data).call(block_identifier=self.block)
